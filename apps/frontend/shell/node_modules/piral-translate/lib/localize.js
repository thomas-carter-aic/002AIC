import { flattenTranslations } from './flatten-translations';
function defaultFallback(key, language) {
    if (process.env.NODE_ENV === 'production') {
        return language ? '...' : '';
    }
    else {
        if (language) {
            console.warn(`Missing translation of "${key}" in language "${language}".`);
            return `__${language}_${key}__`;
        }
        else {
            return '';
        }
    }
}
function formatMessage(message, variables) {
    return message.replace(/{{\s*([A-Za-z0-9_.]+)\s*}}/g, (_match, p1) => {
        return p1 in variables ? variables[p1] ?? '' : `{{${p1}}}`;
    });
}
export class Localizer {
    /**
     * Creates a new instance of a localizer.
     */
    constructor(messages, language, languages, fallback = defaultFallback) {
        this.language = language;
        this.languages = languages;
        this.fallback = fallback;
        this.messages = flattenTranslations(messages);
    }
    /**
     * Localizes the given key via the global translations.
     * @param key The key of the translation snippet.
     * @param variables The optional variables to use.
     */
    localizeGlobal(key, variables) {
        return this.localizeBase(key, variables);
    }
    /**
     * Localizes the given key via the local translations.
     * Uses the global translations as fallback mechanism.
     * @param localMessages The local translations to prefer.
     * @param key The key of the translation snippet.
     * @param variables The optional variables to use.
     */
    localizeLocal(localMessages, key, variables) {
        const message = this.translateMessage(localMessages, key, variables);
        if (message === undefined) {
            return this.localizeBase(key, variables);
        }
        return message;
    }
    localizeBase(key, variables) {
        const message = this.translateMessage(this.messages, key, variables);
        if (message === undefined) {
            return this.fallback(key, this.language, this.messages, variables);
        }
        return message;
    }
    translateMessage(messages, key, variables) {
        const language = this.language;
        const translations = language && messages[language];
        const translation = translations && translations[key];
        return translation && (variables ? formatMessage(translation, variables) : translation);
    }
}
//# sourceMappingURL=localize.js.map