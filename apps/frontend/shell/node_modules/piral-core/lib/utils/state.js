import { cloneElement, createElement } from 'react';
import { toExtension } from './extension';
import { withKey, withoutKey, appendItem, excludeOn } from './helpers';
/**
 * Returns a dispatcher that includes all mentioned dispatchers.
 * @param dispatchers The dispatchers to include.
 */
export function withAll(...dispatchers) {
    return (state) => {
        for (const dispatcher of dispatchers) {
            state = dispatcher(state);
        }
        return state;
    };
}
/**
 * Returns a dispatcher that adds a page registration.
 * @param name The path of the page to register.
 * @param value The value of the page to register.
 * @returns The dispatcher.
 */
export function withPage(name, value) {
    return (state) => ({
        ...state,
        registry: {
            ...state.registry,
            pages: withKey(state.registry.pages, name, value),
        },
    });
}
/**
 * Returns a dispatcher that removes a page registration.
 * @param name The path of the page to unregister.
 * @returns The dispatcher.
 */
export function withoutPage(name) {
    return (state) => ({
        ...state,
        registry: {
            ...state.registry,
            pages: withoutKey(state.registry.pages, name),
        },
    });
}
/**
 * Returns a dispatcher that adds an extension registration.
 * @param name The name of the extension to register.
 * @param value The value of the extension to register.
 * @returns The dispatcher.
 */
export function withExtension(name, value) {
    return (state) => ({
        ...state,
        registry: {
            ...state.registry,
            extensions: withKey(state.registry.extensions, name, appendItem(state.registry.extensions[name], value)),
        },
    });
}
/**
 * Returns a dispatcher that removes an extension registration.
 * @param name The name of the extension to unregister.
 * @param reference The reference for the extension.
 * @returns The dispatcher.
 */
export function withoutExtension(name, reference) {
    return (state) => ({
        ...state,
        registry: {
            ...state.registry,
            extensions: withKey(state.registry.extensions, name, excludeOn(state.registry.extensions[name], (m) => m.reference === reference)),
        },
    });
}
/**
 * Returns a dispatcher that adds an extension registration from the root (no Pilet API).
 * @param name The name of the extension to register.
 * @param component The extension's component to use.
 * @returns The dispatcher.
 */
export function withRootExtension(name, component) {
    return withExtension(name, {
        component: toExtension(component),
        defaults: {},
        pilet: '',
        reference: component,
    });
}
/**
 * Returns a dispatcher that adds another provider.
 * @param provider The provider to include.
 * @returns The dispatcher.
 */
export function withProvider(provider) {
    const wrapper = (props) => cloneElement(provider, props);
    return (state) => ({
        ...state,
        provider: !state.provider ? wrapper : (props) => createElement(state.provider, undefined, wrapper(props)),
    });
}
/**
 * Returns a dispatcher that registers another route.
 * @param path The path of the route to register.
 * @param component The component representing the route.
 * @returns The dispatcher.
 */
export function withRoute(path, component) {
    return (state) => ({
        ...state,
        routes: withKey(state.routes, path, component),
    });
}
//# sourceMappingURL=state.js.map