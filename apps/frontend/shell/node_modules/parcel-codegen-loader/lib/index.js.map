{
  "version": 3,
  "sources": ["../src/index.ts", "../../codegen-lib/src/index.ts"],
  "sourcesContent": ["import validateOptions from 'schema-utils';\nimport { getOptions } from 'loader-utils';\nimport { createCodegenHost } from 'codegen-lib';\nimport type { Compiler } from 'webpack';\n\nconst schema = {\n  type: 'object' as const,\n  properties: {},\n  additionalProperties: false,\n};\n\nconst rootDir = process.cwd();\nconst codegen = createCodegenHost(rootDir);\n\nexport default async function loader(source: string, map: string, meta: any) {\n  const options = getOptions(this);\n\n  validateOptions(schema, options, {\n    name: 'Codegen Loader',\n    baseDataPath: 'options',\n  });\n\n  const name = this.resourcePath;\n  const compiler = this._compiler as Compiler;\n  const callback = this.async();\n\n  try {\n    const content = await codegen.generate({\n      name,\n      options: {\n        outDir: compiler?.options?.output?.path,\n        rootDir,\n      },\n      addDependency: (file) => this.addDependency(file),\n    });\n\n    callback(null, content.value, map, meta);\n  } catch (err) {\n    callback(err, source);\n  }\n}\n", "import { dirname } from 'path';\nimport { readFile } from 'fs/promises';\nimport { createRequire } from 'module';\n\nfunction reloadGenerator(requireModule: any, name: string) {\n  const path = requireModule.resolve(name);\n  delete requireModule.cache[path];\n  return requireModule(name);\n}\n\nfunction noop() {}\n\n// This is right now needed as a .codegen file will be\n// reported as having an invalid file extension; so\n// Node.js will refuse to load / evaluate it\nasync function dynamicCodegenImport(file: string) {\n  const dir = dirname(file);\n  const text = await readFile(file, 'utf8');\n  const code = replaceRelativeImports(text, dir);\n  const content = Buffer.from(code).toString('base64');\n  const url = `data:text/javascript;base64,${content}`;\n  return await import(url);\n}\n\n// Converts relative paths to absolute paths - only needed for (some) imports\nfunction replaceRelativeImports(content: string, absoluteBase: string) {\n  const regex = /import\\s+([^'\"]+)\\s+from\\s+(['\"])\\.\\/([^'\"]+)\\2/g;\n\n  // Replace relative imports with absolute imports\n  return content.replace(regex, (_, imports, quote, relativePath) => {\n    const absolutePath = `${absoluteBase}/${relativePath}`;\n    return `import ${imports} from ${quote}file://${absolutePath}${quote}`;\n  });\n}\n\nexport interface CodegenDetailsOptions {\n  outDir?: string;\n  rootDir?: string;\n}\n\nexport type CodegenType = 'auto' | 'esm' | 'cjs';\n\nexport interface CodegenDetails {\n  name: string;\n  type?: CodegenType;\n  options: CodegenDetailsOptions;\n  addDependency?(file: string, options: CodegenDetailsOptions): void;\n}\n\nexport interface CodegenContext {\n  name: string;\n  options: CodegenDetailsOptions;\n  addDependency(file: string, options: CodegenDetailsOptions): void;\n}\n\nexport interface CodegenResult {\n  value: string;\n  type: string;\n}\n\nexport interface CodegenFile {\n  (this: CodegenContext): string | CodegenResult | Promise<string | CodegenResult>;\n  type?: string;\n}\n\nexport interface CodegenHost {\n  load(name: string, type: CodegenType): Promise<CodegenFile>;\n  generate(details: CodegenDetails): Promise<CodegenResult>;\n}\n\nexport function createCodegenHost(fileOrDirName: string): CodegenHost {\n  const requireModule = createRequire(fileOrDirName);\n  const host: CodegenHost = {\n    load(name, type) {\n      switch (type) {\n        case 'cjs':\n          return Promise.resolve(reloadGenerator(requireModule, name));\n        case 'esm':\n          return dynamicCodegenImport(name).then((result) => result.default || result);\n        case 'auto':\n        default:\n          if (\n            name.endsWith('.mjs.codegen') ||\n            name.endsWith('.esm.codegen') ||\n            name.endsWith('.module.codegen') ||\n            name.endsWith('.m.codegen')\n          ) {\n            return host.load(name, 'esm');\n          }\n\n          return host.load(name, 'cjs');\n      }\n    },\n    async generate(details) {\n      const { name, type = 'auto', options = {}, addDependency = noop } = details;\n\n      if (typeof name !== 'string') {\n        throw new Error(`You need to pass in a string for \"name\". Received: \"${name}\".`);\n      }\n\n      const generator = await host.load(name, type);\n\n      if (typeof generator !== 'function') {\n        throw new Error(`The codegen module \"${name}\" does not export a function and is invalid.`);\n      }\n\n      const result = await (generator.call({\n        name,\n        options,\n        addDependency,\n      }) as ReturnType<CodegenFile>);\n\n      if (typeof result === 'string') {\n        const type = typeof generator.type === 'string' ? generator.type : 'js';\n\n        return {\n          type,\n          value: result,\n        };\n      }\n\n      if (result && typeof result === 'object' && typeof result.value === 'string' && typeof result.type === 'string') {\n        return result;\n      }\n\n      throw new Error(\n        `The codegen module \"${name}\" did not generate a valid result (string or object). It returned: \"${result}\".`,\n      );\n    },\n  };\n  return host;\n}\n"],
  "mappings": "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",
  "names": ["type", "validateOptions"]
}
