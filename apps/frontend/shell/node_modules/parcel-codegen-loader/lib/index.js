var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  default: () => loader
});
module.exports = __toCommonJS(index_exports);
var import_schema_utils = __toESM(require("schema-utils"));
var import_loader_utils = require("loader-utils");

// ../codegen-lib/lib/esm/index.mjs
var import_path = require("path");
var import_promises = require("fs/promises");
var import_module = require("module");
function reloadGenerator(requireModule, name) {
  const path = requireModule.resolve(name);
  delete requireModule.cache[path];
  return requireModule(name);
}
function noop() {
}
async function dynamicCodegenImport(file) {
  const dir = (0, import_path.dirname)(file);
  const text = await (0, import_promises.readFile)(file, "utf8");
  const code = replaceRelativeImports(text, dir);
  const content = Buffer.from(code).toString("base64");
  const url = `data:text/javascript;base64,${content}`;
  return await import(url);
}
function replaceRelativeImports(content, absoluteBase) {
  const regex = /import\s+([^'"]+)\s+from\s+(['"])\.\/([^'"]+)\2/g;
  return content.replace(regex, (_, imports, quote, relativePath) => {
    const absolutePath = `${absoluteBase}/${relativePath}`;
    return `import ${imports} from ${quote}file://${absolutePath}${quote}`;
  });
}
function createCodegenHost(fileOrDirName) {
  const requireModule = (0, import_module.createRequire)(fileOrDirName);
  const host = {
    load(name, type) {
      switch (type) {
        case "cjs":
          return Promise.resolve(reloadGenerator(requireModule, name));
        case "esm":
          return dynamicCodegenImport(name).then((result) => result.default || result);
        case "auto":
        default:
          if (name.endsWith(".mjs.codegen") || name.endsWith(".esm.codegen") || name.endsWith(".module.codegen") || name.endsWith(".m.codegen")) {
            return host.load(name, "esm");
          }
          return host.load(name, "cjs");
      }
    },
    async generate(details) {
      const { name, type = "auto", options = {}, addDependency = noop } = details;
      if (typeof name !== "string") {
        throw new Error(`You need to pass in a string for "name". Received: "${name}".`);
      }
      const generator = await host.load(name, type);
      if (typeof generator !== "function") {
        throw new Error(`The codegen module "${name}" does not export a function and is invalid.`);
      }
      const result = await generator.call({
        name,
        options,
        addDependency
      });
      if (typeof result === "string") {
        const type2 = typeof generator.type === "string" ? generator.type : "js";
        return {
          type: type2,
          value: result
        };
      }
      if (result && typeof result === "object" && typeof result.value === "string" && typeof result.type === "string") {
        return result;
      }
      throw new Error(
        `The codegen module "${name}" did not generate a valid result (string or object). It returned: "${result}".`
      );
    }
  };
  return host;
}

// src/index.ts
var schema = {
  type: "object",
  properties: {},
  additionalProperties: false
};
var rootDir = process.cwd();
var codegen = createCodegenHost(rootDir);
async function loader(source, map, meta) {
  const options = (0, import_loader_utils.getOptions)(this);
  (0, import_schema_utils.default)(schema, options, {
    name: "Codegen Loader",
    baseDataPath: "options"
  });
  const name = this.resourcePath;
  const compiler = this._compiler;
  const callback = this.async();
  try {
    const content = await codegen.generate({
      name,
      options: {
        outDir: compiler?.options?.output?.path,
        rootDir
      },
      addDependency: (file) => this.addDependency(file)
    });
    callback(null, content.value, map, meta);
  } catch (err) {
    callback(err, source);
  }
}
//# sourceMappingURL=index.js.map
