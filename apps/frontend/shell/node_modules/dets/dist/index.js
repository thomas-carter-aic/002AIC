var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  addAmbientModules: () => addAmbientModules,
  addAvailableImports: () => addAvailableImports,
  createDiffPlugin: () => createDiffPlugin,
  createExcludePlugin: () => createExcludePlugin,
  fillExportsFromApi: () => fillExportsFromApi,
  fillExportsFromReferences: () => fillExportsFromReferences,
  fillExportsFromTypes: () => fillExportsFromTypes,
  generateDeclaration: () => generateDeclaration,
  processVisitorContext: () => processVisitorContext,
  retrieveTypings: () => retrieveTypings,
  setupVisitorContext: () => setupVisitorContext
});
module.exports = __toCommonJS(index_exports);

// src/commands.ts
var ts5 = __toESM(require("typescript"));
var import_path3 = require("path");

// src/helpers/comments.ts
var import_typescript = require("typescript");
function isUnique(value, index, self) {
  return self.indexOf(value) === index;
}
function getAllJsDocs(checker, decls) {
  const allDocs = decls.map((decl) => getJsDocs(checker, decl));
  return {
    comment: allDocs.map((m) => m.comment).reduce((p, c) => [...p, ...c], []).filter(isUnique),
    tags: allDocs.map((m) => m.tags).reduce((p, c) => [...p, ...c], []).filter(isUnique)
  };
}
function getJsDocs(checker, node) {
  if ((0, import_typescript.isMethodDeclaration)(node) || (0, import_typescript.isMethodSignature)(node) || (0, import_typescript.isCallSignatureDeclaration)(node)) {
    const sign = checker.getSignatureFromDeclaration(node);
    if (sign) {
      return {
        comment: sign.getDocumentationComment(checker),
        tags: sign.getJsDocTags()
      };
    }
  }
  return {
    comment: node.symbol?.getDocumentationComment(checker),
    tags: node.symbol?.getJsDocTags()
  };
}
var newLineTags = ["example"];
var removedTags = ["dets_removeprop", "dets_removeclause", "dets_preserve", "dets_ignore"];
function stringifyJsDocTagText(txt) {
  if (typeof txt === "string") {
    if (txt.startsWith("http ://") || txt.startsWith("https ://")) {
      return txt.replace(" ", "");
    }
    return txt;
  } else if (Array.isArray(txt)) {
    return txt.map((s) => s.text).join("");
  }
  return "";
}
function stringifyJsDocs(doc) {
  const tags = (doc.tags || []).filter((m) => !removedTags.includes(m.name)).map((m) => `@${m.name}${newLineTags.includes(m.name) ? "\n" : m.text ? " " : ""}${stringifyJsDocTagText(m.text)}`);
  const result = doc.comment?.map((m) => m.text) ?? [];
  if (tags && result.length) {
    return [result.join(""), ...tags].join("\n");
  } else if (tags) {
    return tags.join("\n");
  } else {
    return result.join("");
  }
}
function shouldDrop(canDrop, tags) {
  let found = false;
  if (tags) {
    for (const tag of tags) {
      switch (tag.name) {
        case "ignore":
          found = canDrop;
          break;
        case "dets_ignore":
          return true;
        case "dets_preserve":
          return false;
      }
    }
  }
  return found;
}
function getCommentOrDrop(checker, node, canDrop = false) {
  const doc = getJsDocs(checker, node);
  if (shouldDrop(canDrop, doc.tags)) {
    return void 0;
  }
  return stringifyJsDocs(doc);
}
function getComment(checker, node) {
  const doc = getJsDocs(checker, node);
  return stringifyJsDocs(doc);
}

// src/helpers/identifiers.ts
var import_typescript2 = require("typescript");
var import_path = require("path");

// src/helpers/constants.ts
var tslibRoot = "/node_modules/typescript/lib";
var tslibPrefix = "lib.";
var globalFiles = ["globals.d.ts", "global.d.ts"];
var globalIndicator = "__global";
var modulesRoot = "/node_modules/";
var typesRoot = "/node_modules/@types/";

// src/helpers/identifiers.ts
function getLibRefName(libName) {
  if (libName[0] === "@") {
    libName = libName.substring(1);
  }
  const parts = libName.split(/[\/\-\.]/g);
  return parts.map((p) => p[0].toUpperCase() + p.substring(1)).join("");
}
function getTypeRefName(name) {
  if ((0, import_typescript2.isIdentifier)(name)) {
    return name.text;
  } else {
    const ns = getTypeRefName(name.left);
    return `${ns}.${name.right.text}`;
  }
}
function getPredicateName(name) {
  if ((0, import_typescript2.isIdentifier)(name)) {
    return name.text;
  } else {
    return "this";
  }
}
function getExportName(name) {
  if (!name) {
    return void 0;
  } else if ((0, import_typescript2.isIdentifier)(name)) {
    return name.text;
  } else if ((0, import_typescript2.isStringLiteral)(name)) {
    return name.text;
  } else {
    return name.text;
  }
}
function getParameterElement(element) {
  const spread = "dotDotDotToken" in element && element.dotDotDotToken ? "..." : "";
  const name = (0, import_typescript2.isBindingElement)(element) ? getParameterName(element.name) : getParameterName(element);
  return `${spread}${name}`;
}
function getParameterName(name) {
  if ((0, import_typescript2.isIdentifier)(name)) {
    return name.text;
  } else if ((0, import_typescript2.isObjectBindingPattern)(name)) {
    const content = name.elements.map(getParameterElement).join(", ");
    return `{ ${content} }`;
  } else if ((0, import_typescript2.isArrayBindingPattern)(name)) {
    const content = name.elements.map(getParameterElement).join(", ");
    return `[${content}]`;
  } else {
    return "";
  }
}
function makeModule(fileName, root) {
  const relFile = (0, import_path.relative)(root, fileName);
  const ext = (0, import_path.extname)(fileName);
  const file = !relFile.startsWith(".") ? `./${relFile}` : relFile;
  return file.substring(0, file.length - ext.length);
}
function getLibName(fileName, root) {
  if (fileName) {
    if (fileName.indexOf(typesRoot) !== -1) {
      const start = fileName.lastIndexOf(typesRoot) + typesRoot.length;
      const name = fileName.substring(start).split("/").shift();
      if (name.indexOf("__") !== -1) {
        const [scope, lib] = name.split("__");
        return `@${scope}/${lib}`;
      }
      return name;
    } else if (fileName.indexOf(modulesRoot) !== -1) {
      const start = fileName.lastIndexOf(modulesRoot) + modulesRoot.length;
      const [scope, lib] = fileName.substring(start).split("/");
      if (scope.indexOf("@") === 0) {
        return `${scope}/${lib}`;
      }
      return scope;
    } else {
      return makeModule(fileName, root);
    }
  }
  return void 0;
}

// src/helpers/node.ts
var import_typescript3 = require("typescript");
function getModule(node) {
  while (node) {
    if ((0, import_typescript3.isModuleDeclaration)(node) && (0, import_typescript3.isSourceFile)(node.parent) && (0, import_typescript3.isStringLiteral)(node.name)) {
      return node.name.text;
    }
    node = node.parent;
  }
  return void 0;
}
function getDeclarationFromSymbol(checker, symbol) {
  if (!symbol) {
    return void 0;
  } else if (symbol.flags === import_typescript3.SymbolFlags.Alias) {
    const aliasSymbol = checker.getAliasedSymbol(symbol);
    return getDeclarationFromSymbol(checker, aliasSymbol);
  } else {
    const decl = symbol.valueDeclaration || symbol.declarations?.[0];
    if (decl && (0, import_typescript3.isImportSpecifier)(decl)) {
      return getDeclarationFromNode(checker, decl.name);
    }
    return decl;
  }
}
function getDeclarationFromNode(checker, node) {
  const symbol = getSymbol(checker, node);
  return getDeclarationFromSymbol(checker, symbol);
}
function getSymbol(checker, node) {
  const symbol = node.aliasSymbol ?? node.symbol;
  if (symbol) {
    return symbol;
  } else if ((0, import_typescript3.isTypeReferenceNode)(node)) {
    const ref = node.typeName;
    return ref.aliasSymbol ?? ref.symbol ?? checker.getSymbolAtLocation(ref);
  } else {
    return checker.getSymbolAtLocation(node);
  }
}
function isDefaultExport(node) {
  return node.symbol?.name === "default";
}
function shouldInclude(node) {
  return (0, import_typescript3.isModuleDeclaration)(node) || (0, import_typescript3.isExportDeclaration)(node) || isNodeExported(node);
}
function isNodeExported(node, alsoTopLevel = false) {
  return (0, import_typescript3.isExportAssignment)(node) || ((0, import_typescript3.getCombinedModifierFlags)(node) & import_typescript3.ModifierFlags.Export) !== 0 || alsoTopLevel && !!node.parent && node.parent.kind === import_typescript3.SyntaxKind.SourceFile;
}
function isPrivate(type) {
  return type.kind === import_typescript3.SyntaxKind.PrivateKeyword;
}
function isPublic(type) {
  return type.kind === import_typescript3.SyntaxKind.PublicKeyword;
}
function isStatic(type) {
  return type.kind === import_typescript3.SyntaxKind.StaticKeyword;
}
function isProtected(type) {
  return type.kind === import_typescript3.SyntaxKind.ProtectedKeyword;
}
function isReadonly(type) {
  return type.kind === import_typescript3.SyntaxKind.ReadonlyKeyword;
}

// src/helpers/paths.ts
var import_path2 = require("path");
function findAppRoot(root, app) {
  return (0, import_path2.resolve)(root, app);
}
var pathCache = {};
function isBaseLib(path) {
  if (path in pathCache) {
    return pathCache[path];
  } else if (path) {
    const parts = path.split("/");
    const part = parts.pop();
    const newPath = parts.join("/");
    const result = newPath.endsWith(tslibRoot) && part.startsWith(tslibPrefix) || globalFiles.includes(part);
    pathCache[path] = result;
    return result;
  } else {
    return false;
  }
}

// src/helpers/strings.ts
var checkIdentifier = /^[a-zA-Z\_\$][a-zA-Z0-9\_\$]*$/;
function makeIdentifier(identifier) {
  return checkIdentifier.test(identifier) ? identifier : JSON.stringify(identifier);
}
function formatContent(content) {
  return content.split("\n").map((line) => line ? `  ${line}
` : "\n").join("");
}
function toContent(lines, terminator) {
  const content = lines.map((line) => `${line}${terminator}`).join("\n");
  return formatContent(content);
}
function toBlock(lines, terminator) {
  if (lines.length > 0) {
    return `{
${toContent(lines, terminator)}}`;
  }
  return "{}";
}

// src/helpers/symbol.ts
var import_typescript4 = require("typescript");
function fullyQualifiedName(symbol, delimiter) {
  const parts = [];
  do {
    parts.push(symbol.name);
    symbol = symbol.parent;
  } while (symbol && symbol.flags === import_typescript4.SymbolFlags.NamespaceModule && symbol.name !== globalIndicator);
  return parts.reverse().join(delimiter);
}
function isGlobal(symbol) {
  const parent = symbol?.parent;
  if (parent) {
    if (parent.name === globalIndicator) {
      return true;
    }
    return isGlobal(parent);
  }
  return false;
}
function getSymbolName(symbol) {
  if (symbol.flags === import_typescript4.SymbolFlags.EnumMember) {
    return `${symbol.parent.name}.${symbol.name}`;
  } else if (symbol.parent?.flags === import_typescript4.SymbolFlags.NamespaceModule) {
    return fullyQualifiedName(symbol, ".");
  }
  return symbol.name;
}
function getModifiers(symbol) {
  const decorators = [];
  if (symbol) {
    const modifiers = symbol.declarations?.[0]?.modifiers ?? [];
    modifiers.some(isPrivate) && decorators.push("private");
    modifiers.some(isPublic) && decorators.push("public");
    modifiers.some(isProtected) && decorators.push("protected");
    modifiers.some(isStatic) && decorators.push("static");
    modifiers.some(isReadonly) && decorators.push("readonly");
  }
  return decorators.join(" ");
}

// src/output/stringify.ts
function stringifyComment(type) {
  if (type.comment) {
    const lines = type.comment.split("\n").map((line) => ` * ${line}
`).join("");
    return `/**
${lines} */
`;
  }
  return "";
}
function stringifyPropName(name) {
  return typeof name === "string" ? makeIdentifier(name) : `[${stringifyNode(name)}]`;
}
function stringifyTupleProp(type) {
  const target = type.valueType;
  const comment = stringifyComment(type);
  const isOpt = type.optional ? "?" : "";
  const name = stringifyPropName(type.name);
  if (typeof target === "undefined") {
    return `${comment}${name}${isOpt}: any`;
  } else if (target.kind === "function") {
    return `${comment}${name}${isOpt}: ${stringifySignature(target, 0 /* default */)}`;
  } else {
    return `${comment}${name}${isOpt}: ${stringifyNode(target)}`;
  }
}
function stringifyProp(type) {
  const target = type.valueType;
  const comment = stringifyComment(type);
  const isOpt = type.optional ? "?" : "";
  const modifier = type.modifiers ? `${type.modifiers} ` : "";
  const name = stringifyPropName(type.name);
  if (typeof target === "undefined") {
    return `${comment}${modifier}${name}${isOpt}: any`;
  } else if (target.kind === "function") {
    return `${comment}${modifier}${name}${isOpt}${stringifySignature(target, 1 /* property */)}`;
  } else {
    return `${comment}${modifier}${name}${isOpt}: ${stringifyNode(target)}`;
  }
}
function stringifyParameter(param) {
  const isOpt = param.optional ? "?" : "";
  const spread = param.spread ? "..." : "";
  const modifiers = param.modifiers ? `${param.modifiers} ` : "";
  return `${modifiers}${spread}${param.param}${isOpt}: ${stringifyNode(param.value)}`;
}
function stringifyParameters(params) {
  return params.map(stringifyParameter).join(", ");
}
function stringifySignature(type, mode, anonymous = false) {
  const ctor = type.kind === "new" ? "new " : "";
  const prop = (mode & 1 /* property */) !== 0;
  const paren = (mode & 2 /* parenthesis */) !== 0;
  const comment = anonymous ? stringifyComment(type) : "";
  const parameters = stringifyParameters(type.parameters);
  const ta = stringifyTypeArgs(type);
  const rt = stringifyNode(type.returnType);
  const del = prop ? ": " : " => ";
  const result = `${ctor}${ta}(${parameters})${del}${rt}`;
  const fn = paren ? `(${result})` : result;
  return `${comment}${fn}`;
}
function stringifyConstructor(type) {
  const parameters = stringifyParameters(type.parameters);
  const modifiers = type.modifiers ? `${type.modifiers} ` : "";
  return `${modifiers}constructor(${parameters})`;
}
function stringifyIndex(type) {
  const isOpt = type.optional ? "?" : "";
  const index = stringifyParameters(type.parameters);
  return `[${index}]${isOpt}: ${stringifyNode(type.valueType)}`;
}
function stringifyMapped(type) {
  const isOpt = type.optional ? "?" : "";
  const index = `${type.name} in ${stringifyNode(type.constraint)}`;
  return `[${index}]${isOpt}: ${stringifyNode(type.value)}`;
}
function stringifyAccess(type) {
  const right = stringifyNode(type.name);
  const left = stringifyNode(type.object);
  return `${left}.${right}`;
}
function stringifyIndexedAccess(type) {
  const right = stringifyNode(type.index);
  const left = stringifyNode(type.object);
  return `${left}[${right}]`;
}
function stringifyInterface(type) {
  const lines = type.props.map((p) => stringifyNode(p, 1 /* property */));
  if (type.mapped) {
    lines.push(stringifyMapped(type.mapped));
  }
  return toBlock(lines, ";");
}
function stringifyClass(type) {
  const lines = type.props.map((p) => stringifyNode(p));
  return toBlock(lines, ";");
}
function stringifyEnum(values) {
  const lines = values.map((p) => stringifyNode(p));
  return toBlock(lines, ",");
}
function stringifyExtends(type) {
  const { extends: es } = type;
  return es.length ? ` extends ${es.map((t) => stringifyNode(t)).join(", ")}` : "";
}
function stringifyImplements(type) {
  const { implements: is } = type;
  return is.length ? ` implements ${is.map((t) => stringifyNode(t)).join(", ")}` : "";
}
function stringifyTypes(types) {
  return types.map((t) => stringifyNode(t)).join(", ");
}
function stringifyTypeArgs(type) {
  if (type.types?.length > 0) {
    return `<${stringifyTypes(type.types)}>`;
  }
  return "";
}
function stringifyTypeParameter(type) {
  const name = stringifyNode(type.parameter);
  const constraint = stringifyNode(type.constraint);
  const defaults = stringifyNode(type.default);
  const constraintClause = constraint ? ` extends ${constraint}` : "";
  const defaultsClause = defaults ? ` = ${defaults}` : "";
  return `${name}${constraintClause}${defaultsClause}`;
}
function stringifyTernary(condition) {
  const t = stringifyNode(condition.check);
  const e = stringifyNode(condition.extends);
  const p = stringifyNode(condition.primary);
  const a = stringifyNode(condition.alternate);
  return `${t} extends ${e} ? ${p} : ${a}`;
}
function stringifyMember(member) {
  const key = stringifyPropName(member.name);
  const name = `${stringifyComment(member)}${key}`;
  if (member.value) {
    return `${name} = ${stringifyNode(member.value)}`;
  }
  return name;
}
function stringifySetAccessor(accessor) {
  const comment = stringifyComment(accessor);
  const modifier = accessor.modifiers ? `${accessor.modifiers} ` : "";
  const args = stringifyParameters(accessor.parameters);
  return `${comment}${modifier}set ${accessor.name}(${args})`;
}
function stringifyGetAccessor(accessor) {
  const comment = stringifyComment(accessor);
  const modifier = accessor.modifiers ? `${accessor.modifiers} ` : "";
  const result = stringifyNode(accessor.type);
  return `${comment}${modifier}get ${accessor.name}(): ${result}`;
}
function stringifyPredicate(predicate) {
  const type = stringifyNode(predicate.value);
  return `${predicate.name} is ${type}`;
}
function stringifyImport(type) {
  const head = `import(${stringifyNode(type.value)})`;
  if (type.qualifier) {
    return `${head}.${type.qualifier}`;
  }
  return head;
}
function stringifyReadonly(type) {
  const value = type.value;
  if (value.kind === "ref" && value.refName === "Array" && value.types.length === 1) {
    const [arg] = value.types;
    return `readonly ${stringifyNode(arg)}[]`;
  }
  return `readonly ${stringifyNode(value)}`;
}
function stringifyNode(type, mode = 0 /* default */) {
  switch (type?.kind) {
    case "interface":
      return stringifyInterface(type);
    case "prop":
      return stringifyProp(type);
    case "tuple-prop":
      return stringifyTupleProp(type);
    case "ref":
      return `${type.refName}${stringifyTypeArgs(type)}`;
    case "typeParameter":
      return stringifyTypeParameter(type);
    case "union":
      return type.types.map((u) => stringifyNode(u, 2 /* parenthesis */)).join(" | ");
    case "intersection":
      return type.types.map((u) => stringifyNode(u)).join(" & ");
    case "member":
      return stringifyMember(type);
    case "conditional":
      return stringifyTernary(type);
    case "readonly":
      return stringifyReadonly(type);
    case "unique":
      return `unique ${stringifyNode(type.value)}`;
    case "keyof":
      return `keyof ${stringifyNode(type.value)}`;
    case "import":
      return stringifyImport(type);
    case "infer":
      return `infer ${stringifyNode(type.parameter)}`;
    case "any":
    case "null":
    case "void":
    case "undefined":
    case "boolean":
    case "unknown":
    case "bigint":
    case "number":
    case "never":
    case "string":
      return type.kind;
    case "nonPrimitive":
      return type.name || "object";
    case "esSymbol":
      return "symbol";
    case "unidentified":
      return "any";
    case "literal":
      return `${type.value}`;
    case "access":
      return stringifyAccess(type);
    case "indexedAccess":
      return stringifyIndexedAccess(type);
    case "index":
      return stringifyIndex(type);
    case "class":
      return `class ${stringifyClass(type)}`;
    case "constructor":
      return stringifyConstructor(type);
    case "mapped":
      return stringifyMapped(type);
    case "substitution":
      return stringifyNode(type.variable);
    case "rest":
      return `...${stringifyNode(type.value)}`;
    case "new":
    case "function":
      return stringifySignature(type, mode, true);
    case "tuple":
      return `[${stringifyTypes(type.types)}]`;
    case "set":
      return stringifySetAccessor(type);
    case "get":
      return stringifyGetAccessor(type);
    case "predicate":
      return stringifyPredicate(type);
    case "template":
      return `\`${type.parts.map((p) => typeof p === "string" ? p : `\${${stringifyNode(p)}}`).join("")}\``;
    case "parenthesis":
      return `(${stringifyNode(type.value)})`;
  }
  return "";
}

// src/output/exports.ts
function stringifyExport(type) {
  switch (type?.kind) {
    case "interface":
      return `${stringifyComment(type)}export interface ${type.name}${stringifyTypeArgs(type)}${stringifyExtends(
        type
      )} ${stringifyInterface(type)}`;
    case "class":
      return `${stringifyComment(type)}export class ${type.name}${stringifyTypeArgs(type)}${stringifyExtends(
        type
      )}${stringifyImplements(type)} ${stringifyClass(type)}`;
    case "alias":
      return `${stringifyComment(type)}export type ${type.name}${stringifyTypeArgs(type)} = ${stringifyNode(
        type.child
      )};`;
    case "enumLiteral":
      return `${stringifyComment(type)}export ${type.const ? "const enum" : "enum"} ${type.name} ${stringifyEnum(
        type.values
      )}`;
    case "const":
      return `${stringifyComment(type)}export const ${type.name}: ${stringifyNode(type.value)};`;
    case "function":
      return `${stringifyComment(type)}export function ${type.name}${stringifySignature(
        type,
        1 /* property */
      )};`;
    case "default":
      const sc = type.value.kind === "class" ? "" : ";";
      return `${stringifyComment(type)}export default ${stringifyNode(type.value)}${sc}`;
  }
  return "";
}
function stringifyExports(refs) {
  return refs.map((r) => stringifyExport(r)).filter((m) => !!m).join("\n\n");
}

// src/output/module.ts
function stringifyModule(name, refs) {
  const content = stringifyExports(refs);
  const formattedContent = formatContent(content);
  return `declare module "${name}" {
${formattedContent}}`;
}

// src/output/declaration.ts
function stringifyDeclaration(context) {
  const { noModuleDeclaration } = context.flags;
  const modules = Object.keys(context.modules).filter((moduleName) => Object.keys(context.modules[moduleName]).length > 0).map((moduleName) => {
    const refs = context.modules[moduleName];
    if (noModuleDeclaration && moduleName === context.name) {
      return stringifyExports(refs);
    }
    return stringifyModule(moduleName, refs);
  }).join("\n\n");
  const preamble = context.usedImports.map((lib) => `import * as ${getLibRefName(lib)} from '${lib}';`).join("\n");
  if (preamble) {
    return `${preamble}

${modules}`;
  }
  return modules;
}

// src/logger.ts
var defaultLogger = {
  error(message) {
    throw new Error(message);
  },
  warn(message) {
    console.warn(message);
  },
  info(message) {
    console.info(message);
  },
  verbose(message) {
    console.log(message);
  }
};
var wrapLogger = (logger, level) => {
  return {
    error(message) {
      level >= 1 && logger.error(message);
    },
    warn(message) {
      level >= 2 && logger.warn(message);
    },
    info(message) {
      level >= 3 && logger.info(message);
    },
    verbose(message) {
      level >= 4 && logger.verbose(message);
    }
  };
};

// src/input/api.ts
var import_typescript5 = require("typescript");
function includeApi(context, node, interfaceName) {
  if ((0, import_typescript5.isInterfaceDeclaration)(node) && node.name.text === interfaceName) {
    context.exports.push(node);
  } else {
    context.log.verbose(`Skipping API using interface "${interfaceName}" from node: ${node}`);
  }
}

// src/input/exports.ts
var ts = __toESM(require("typescript"));
function includeExports(context, key, symbol) {
  const defs = {};
  if (symbol) {
    context.checker.getExportsOfModule(symbol).forEach((exp) => {
      const decl = exp.valueDeclaration || exp.declarations?.[0];
      if (!decl) {
      } else if (ts.isExportSpecifier(decl)) {
        const name = decl.name?.text;
        if (name) {
          defs[name] = getDeclarationFromNode(context.checker, decl);
        }
      } else if (ts.isExportAssignment(decl)) {
        defs["default"] = getDeclarationFromNode(context.checker, decl);
      } else if (ts.isVariableDeclaration(decl)) {
        defs[getParameterName(decl.name)] = decl;
      } else if (ts.isFunctionDeclaration(decl) || ts.isInterfaceDeclaration(decl) || ts.isClassDeclaration(decl) || ts.isTypeAliasDeclaration(decl) || ts.isEnumDeclaration(decl)) {
        const name = isDefaultExport(decl) ? "default" : decl.name?.text;
        if (name) {
          defs[name] = decl;
        }
      } else if (ts.isMethodDeclaration(decl) || ts.isPropertyDeclaration(decl)) {
      } else if (ts.isModuleDeclaration(decl)) {
        defs[decl.name.text] = decl;
      } else if (ts.isImportEqualsDeclaration(decl)) {
      } else if (ts.isNamespaceExport(decl)) {
        defs[decl.name.text] = decl;
      } else {
        context.log.warn(`Skipping import of unknown node (kind: ${decl.kind}).`);
      }
    });
  }
  context.availableImports[key] = defs;
}

// src/input/node.ts
var ts4 = __toESM(require("typescript"));

// src/input/utils.ts
var ts2 = __toESM(require("typescript"));
function createBinding(context, lib, name) {
  if (!context.usedImports.includes(lib)) {
    context.usedImports.push(lib);
  }
  return `${getLibRefName(lib)}.${name}`;
}
function getDefault(value) {
  return {
    kind: "default",
    name: "default",
    value
  };
}
function getRef(refName, types = []) {
  return {
    kind: "ref",
    refName,
    types
  };
}
function getSymbolName2(imports, node) {
  if (imports) {
    for (const name of Object.keys(imports)) {
      if (imports[name] === node) {
        return name;
      }
    }
  }
  return void 0;
}
function isImportedFile(node, root, imports) {
  const fn = node.getSourceFile()?.fileName;
  if (fn) {
    const libName = getLibName(fn, root);
    return Object.keys(imports).some((name) => name === libName);
  }
  return false;
}
function getPackage(node, symbol, root, imports) {
  const fn = node.getSourceFile()?.fileName;
  const base = isBaseLib(fn) || false;
  const global = isGlobal(symbol);
  if (!base) {
    const libName = getLibName(fn, root);
    const [lib] = Object.keys(imports).filter((name) => {
      if (global) {
        return name === libName;
      }
      const exports2 = Object.values(imports[name]);
      if (exports2.includes(node)) {
        return true;
      } else if (symbol?.parent?.flags === ts2.SymbolFlags.NamespaceModule) {
        const parentNode = symbol.parent?.declarations[0];
        return exports2.includes(parentNode);
      }
      return false;
    });
    const symbolName = getSymbolName2(imports[lib], node);
    return {
      external: !!lib,
      moduleName: lib && getModule(node) || lib,
      symbolName,
      global,
      base,
      lib,
      fn
    };
  }
  return {
    external: true,
    moduleName: void 0,
    symbolName: void 0,
    global,
    base,
    lib: void 0,
    fn
  };
}

// src/input/includes.ts
var ts3 = __toESM(require("typescript"));
function isText(actual, expected) {
  if (typeof actual === "string") {
    return actual === expected;
  } else if (Array.isArray(actual)) {
    return actual.some((m) => m.text === expected);
  }
  return false;
}
function includeClauses(context, clauses, newClause, tags = []) {
  const types = [];
  for (const clause of newClause.types) {
    const decl = getDeclarationFromNode(context.checker, clause.expression);
    const name = decl?.symbol?.name;
    if (decl && !tags.some((m) => m.name === "dets_removeclause" && isText(m.text, name))) {
      types.push(clause);
    }
  }
  clauses.push({
    ...newClause,
    types: ts3.factory.createNodeArray(types)
  });
}
function includeProp(props, newProp, getPropName, tags = []) {
  const name = getPropName(newProp.name);
  if (tags.some((m) => m.name === "dets_removeprop" && isText(m.text, name))) {
    return;
  }
  for (const oldProp of props) {
    if (oldProp.kind === newProp.kind && getPropName(oldProp.name) === name) {
      if (!ts3.isMethodSignature(newProp) && !ts3.isCallSignatureDeclaration(newProp)) {
        return;
      }
    }
  }
  props.push(newProp);
}

// src/input/node.ts
var DeclVisitor = class {
  constructor(context) {
    this.context = context;
    this.queue = [];
    this.modules = [];
    this.processed = [];
    const [defaultModule] = Object.keys(context.modules ?? {});
    this.refs = context.modules[defaultModule] ?? [];
    this.names = context.moduleNames[defaultModule] ?? /* @__PURE__ */ new Map();
    for (const node of context.exports) {
      this.enqueue(node);
    }
  }
  logVerbose(message) {
    this.context.log.verbose(message);
  }
  logWarn(message) {
    this.context.log.warn(message);
  }
  printWarning(type, node) {
    this.logWarn(
      `Could not resolve ${type} at position ${node.pos} of "${node.getSourceFile()?.fileName}". Kind: ${node.kind}.`
    );
  }
  swapName(oldName, newName) {
    const refs = this.refs;
    const last = refs.pop();
    if (!last) {
    } else if (last.kind === "default") {
      if (last.value.kind === "ref") {
        const name = last.value.refName;
        for (let i = refs.length; i--; ) {
          const ref = refs[i];
          if (ref.name === name) {
            refs.splice(i, 1, {
              ...ref,
              name: newName
            });
            break;
          }
        }
      }
    } else if ("name" in last && last.name === oldName) {
      refs.push({
        ...last,
        name: newName
      });
    } else {
      refs.push(last);
    }
  }
  findName(node) {
    return this.names.get(node);
  }
  createName(name) {
    const altStart = `${name}___`;
    const available = /* @__PURE__ */ new Set();
    for (const m of this.names.values()) {
      if (m === name || m.startsWith(altStart)) {
        available.add(m);
      }
    }
    const count = available.size;
    if (count) {
      return `${altStart}${count}`;
    }
    return name;
  }
  getName(node, suggested) {
    const existing = this.findName(node);
    if (!existing) {
      this.logVerbose(`Missing "name". Retrieving with suggestion "${suggested}".`);
      const name = this.createName(suggested);
      const decls = node.symbol?.declarations ?? [node];
      decls.forEach((decl) => this.names.set(decl, name));
      return name;
    }
    return existing;
  }
  normalizeName(node) {
    const c = this.context;
    const symbol = node.symbol ?? node.aliasSymbol ?? c.checker.getSymbolAtLocation(node);
    const { moduleName, lib, symbolName, global } = getPackage(node, symbol, c.root, c.availableImports);
    if (!lib) {
      const name = global ? fullyQualifiedName(symbol, "_") : getSymbolName(symbol);
      return this.getName(node, name);
    } else if (global) {
      return fullyQualifiedName(symbol, ".");
    } else {
      return createBinding(c, moduleName, symbolName ?? getSymbolName(symbol));
    }
  }
  convertToTypeNodeFromType(type) {
    const c = this.context.checker;
    return c.typeToTypeNode(type, void 0, ts4.NodeBuilderFlags.NoTruncation);
  }
  convertToTypeNodeFromNode(node) {
    const type = this.context.checker.getTypeAtLocation(node);
    return this.convertToTypeNodeFromType(type);
  }
  valueFromLiteral(node) {
    switch (node.literal.kind) {
      case ts4.SyntaxKind.StringLiteral:
        return JSON.stringify(node.literal.text);
      case ts4.SyntaxKind.TrueKeyword:
        return "true";
      case ts4.SyntaxKind.FalseKeyword:
        return "false";
      case ts4.SyntaxKind.NumericLiteral:
      case ts4.SyntaxKind.BigIntLiteral:
        return node.literal.text;
      case ts4.SyntaxKind.NullKeyword:
        return "null";
      default:
        this.logVerbose(`No match for literal node kind "${node.literal.kind}". Trying to get from type node...`);
        const type = this.context.checker.getTypeFromTypeNode(node);
        return type?.intrinsicName ?? type?.value;
    }
  }
  getInferredType(node) {
    const typeNode = this.convertToTypeNodeFromNode(node);
    return this.getTypeNode(typeNode);
  }
  getUnion(node) {
    return {
      kind: "union",
      types: node.types.map((m) => this.getNode(m))
    };
  }
  getLiteral(node) {
    return {
      kind: "literal",
      value: this.valueFromLiteral(node)
    };
  }
  getNode(node) {
    if (ts4.isTypeNode(node)) {
      return this.getTypeNode(node);
    } else if (ts4.isTypeAliasDeclaration(node) || ts4.isFunctionDeclaration(node) || ts4.isInterfaceDeclaration(node) || ts4.isClassDeclaration(node)) {
      this.enqueue(node);
      return getRef(this.normalizeName(node), this.getTypeParameters(node.typeParameters));
    } else if (isDefaultExport(node) || ts4.isVariableDeclaration(node) || ts4.isVariableStatement(node)) {
      this.enqueue(node);
      return getRef(this.normalizeName(node));
    } else if (ts4.isPropertyAssignment(node)) {
      return {
        kind: "prop",
        modifiers: getModifiers(node.symbol),
        name: node.symbol.name,
        //@ts-ignore
        optional: node.questionToken !== void 0,
        valueType: this.getExpression(node.initializer)
      };
    }
    this.logVerbose(`Node is presumably a reference. Found kind "${node.kind}".`);
    return getRef(node.symbol.name);
  }
  getPropDeclaration(node) {
    const type = node.type ?? this.convertToTypeNodeFromNode(node);
    return this.getTypeNode(type);
  }
  getPropValue(node) {
    if (ts4.isPropertySignature(node)) {
      return this.getTypeNode(node.type);
    } else if (ts4.isMethodSignature(node)) {
      return this.getMethodSignature(node);
    } else if (ts4.isPropertyDeclaration(node)) {
      return this.getPropDeclaration(node);
    } else if (ts4.isMethodDeclaration(node)) {
      return this.getMethodSignature(node);
    }
    this.printWarning("property", node);
  }
  getNormalProp(node) {
    const { checker, flags } = this.context;
    const canDrop = !flags.noIgnore;
    const comment = getCommentOrDrop(checker, node.emitNode?.commentRange ?? node, canDrop);
    if (typeof comment === "string") {
      return {
        kind: "prop",
        name: this.getPropName(node.name),
        modifiers: getModifiers(node.symbol),
        optional: node.questionToken !== void 0,
        comment,
        valueType: this.getPropValue(node)
      };
    }
    this.logVerbose(`The prop "${this.getPropName(node.name)}" was skipped due to @ignore.`);
    return void 0;
  }
  getIndexProp(node) {
    return {
      kind: "index",
      parameters: this.getFunctionParameters(node.parameters),
      optional: node.questionToken !== void 0,
      valueType: this.getTypeNode(node.type)
    };
  }
  getConstructor(node) {
    return {
      kind: "constructor",
      parameters: this.getFunctionParameters(node.parameters),
      modifiers: getModifiers(node.symbol),
      comment: getComment(this.context.checker, node)
    };
  }
  getClassMember(node) {
    const { checker, flags } = this.context;
    const canDrop = !flags.noIgnore;
    const comment = getCommentOrDrop(checker, node, canDrop);
    if (node.name) {
      if (typeof comment === "string") {
        return {
          kind: "prop",
          name: node.name.getText(),
          modifiers: getModifiers(node.symbol),
          optional: false,
          comment,
          valueType: this.getPropValue(node)
        };
      }
      this.logVerbose(`The member "${node.name.getText()}" was skipped due to @ignore.`);
    }
    return void 0;
  }
  getProps(nodes) {
    const props = [];
    nodes?.forEach((node) => {
      if (ts4.isIndexSignatureDeclaration(node)) {
        props.push(this.getIndexProp(node));
      } else if (ts4.isCallSignatureDeclaration(node)) {
        props.push(this.getMethodSignature(node));
      } else if (ts4.isConstructSignatureDeclaration(node)) {
        props.push(this.getConstructorCall(node));
      } else if (ts4.isGetAccessor(node)) {
        const prop = this.getGetAccessor(node);
        prop && props.push(prop);
      } else if (ts4.isSetAccessor(node)) {
        const prop = this.getSetAccessor(node);
        prop && props.push(prop);
      } else if (ts4.isPropertySignature(node)) {
        const prop = this.getNormalProp(node);
        prop && props.push(prop);
      } else {
        this.logVerbose(`Getting props - assuming node of kind "${node?.kind}" is a normal prop.`);
        const prop = this.getNormalProp(node);
        prop && props.push(prop);
      }
    });
    return props;
  }
  getClassMembers(nodes) {
    const members = [];
    nodes?.forEach((node) => {
      if (ts4.isConstructorDeclaration(node)) {
        members.push(this.getConstructor(node));
      } else if (ts4.isCallSignatureDeclaration(node)) {
        members.push(this.getMethodSignature(node));
      } else if (ts4.isConstructSignatureDeclaration(node)) {
        members.push(this.getConstructorCall(node));
      } else if (ts4.isGetAccessor(node)) {
        const member = this.getGetAccessor(node);
        member && members.push(member);
      } else if (ts4.isSetAccessor(node)) {
        const member = this.getSetAccessor(node);
        member && members.push(member);
      } else if (ts4.isIndexSignatureDeclaration(node)) {
        members.push(this.getIndexProp(node));
      } else {
        this.logVerbose(`Getting class members - assuming node of kind "${node?.kind}" is a class member.`);
        const member = this.getClassMember(node);
        member && members.push(member);
      }
    });
    return members;
  }
  getEnumMember(node) {
    const value = node.initializer;
    return {
      kind: "member",
      name: this.getPropName(node.name),
      value: value && this.getExpression(value),
      comment: getComment(this.context.checker, node)
    };
  }
  getEnumMembers(nodes) {
    return nodes?.map((node) => this.getEnumMember(node)) ?? [];
  }
  getReturnType(node) {
    const checker = this.context.checker;
    const type = node.type ?? this.convertToTypeNodeFromType(checker.getReturnTypeOfSignature(checker.getSignatureFromDeclaration(node)));
    return this.getTypeNode(type);
  }
  getFunctionDeclaration(node) {
    const name = this.getName(node, node.name.text);
    return {
      ...this.getMethodSignature(node),
      name
    };
  }
  getMethodSignature(node) {
    return {
      kind: "function",
      name: void 0,
      parameters: this.getFunctionParameters(node.parameters),
      returnType: this.getReturnType(node),
      types: this.getTypeParameters(node.typeParameters),
      comment: getComment(this.context.checker, node)
    };
  }
  getConstructorCall(node) {
    return {
      kind: "new",
      parameters: this.getFunctionParameters(node.parameters),
      returnType: this.getTypeNode(node.type),
      types: this.getTypeParameters(node.typeParameters),
      comment: getComment(this.context.checker, node)
    };
  }
  getTypeParameter(node) {
    return {
      kind: "typeParameter",
      parameter: getRef(node.name.text),
      constraint: node.constraint && this.getTypeNode(node.constraint),
      default: node.default && this.getTypeNode(node.default)
    };
  }
  getTypeParameters(nodes) {
    return nodes?.map((node) => this.getTypeParameter(node)) ?? [];
  }
  getTypeArguments(nodes) {
    return nodes?.map((node) => this.getTypeNode(node)) ?? [];
  }
  getFunctionParameterValue(node) {
    if (node.type) {
      return this.getTypeNode(node.type);
    }
    const typeNode = this.convertToTypeNodeFromNode(node);
    if (typeNode) {
      return this.getTypeNode(typeNode);
    } else if (node.initializer) {
      return this.getExpression(node.initializer);
    } else {
      this.logVerbose(
        `Found unidentified node of kind "${node.kind}" in function parameter value. Falling back to "any".`
      );
      return {
        kind: "any"
      };
    }
  }
  getFunctionParameter(node) {
    return {
      kind: "parameter",
      param: getParameterName(node.name),
      spread: node.dotDotDotToken !== void 0,
      optional: node.questionToken !== void 0 || node.initializer !== void 0,
      modifiers: getModifiers(node.symbol),
      value: this.getFunctionParameterValue(node)
    };
  }
  getFunctionParameters(nodes) {
    return nodes?.map((node) => this.getFunctionParameter(node)) ?? [];
  }
  getIndexAccess(node) {
    return {
      kind: "indexedAccess",
      index: this.getTypeNode(node.indexType),
      object: this.getTypeNode(node.objectType)
    };
  }
  getTypeOperator(node) {
    switch (node.operator) {
      case ts4.SyntaxKind.KeyOfKeyword:
        return {
          kind: "keyof",
          value: this.getTypeNode(node.type)
        };
      case ts4.SyntaxKind.UniqueKeyword:
        return {
          kind: "unique",
          value: this.getTypeNode(node.type)
        };
      case ts4.SyntaxKind.ReadonlyKeyword:
        return {
          kind: "readonly",
          value: this.getTypeNode(node.type)
        };
      default:
        this.logWarn(`Found unknown type operator node of kind "${node.kind}".`);
    }
  }
  getMappedType(node) {
    const p = node.typeParameter;
    return {
      kind: "interface",
      name: void 0,
      extends: [],
      props: [],
      types: [],
      comment: getComment(this.context.checker, node),
      mapped: {
        kind: "mapped",
        constraint: this.getTypeNode(p.constraint),
        name: p.name.text,
        optional: node.questionToken !== void 0,
        value: this.getTypeNode(node.type)
      }
    };
  }
  getConditionalType(node) {
    return {
      kind: "conditional",
      alternate: this.getTypeNode(node.falseType),
      check: this.getTypeNode(node.checkType),
      extends: this.getTypeNode(node.extendsType),
      primary: this.getTypeNode(node.trueType)
    };
  }
  getPredicate(node) {
    return {
      kind: "predicate",
      name: getPredicateName(node.parameterName),
      value: this.getTypeNode(node.type)
    };
  }
  getSetAccessor(node) {
    const { checker, flags } = this.context;
    const canDrop = !flags.noIgnore;
    const comment = getCommentOrDrop(checker, node, canDrop);
    if (typeof comment === "string") {
      return {
        kind: "set",
        name: this.getPropName(node.name),
        parameters: this.getFunctionParameters(node.parameters),
        comment,
        modifiers: getModifiers(node.symbol)
      };
    }
    this.logVerbose(`The setter "${this.getPropName(node.name)}" was skipped due to @ignore.`);
    return void 0;
  }
  getGetAccessor(node) {
    const { checker, flags } = this.context;
    const canDrop = !flags.noIgnore;
    const comment = getCommentOrDrop(checker, node, canDrop);
    if (typeof comment === "string") {
      return {
        kind: "get",
        name: this.getPropName(node.name),
        type: this.getReturnType(node),
        comment,
        modifiers: getModifiers(node.symbol)
      };
    }
    this.logVerbose(`The getter "${this.getPropName(node.name)}" was skipped due to @ignore.`);
    return void 0;
  }
  getTypeReference(node) {
    const c = this.context.checker;
    const decl = getDeclarationFromNode(c, node);
    if (decl && !ts4.isTypeParameterDeclaration(decl)) {
      this.enqueue(decl);
      return getRef(this.normalizeName(decl), this.getTypeArguments(node.typeArguments));
    }
    return getRef(getTypeRefName(node.typeName), this.getTypeArguments(node.typeArguments));
  }
  getTypeLiteral(node) {
    return {
      kind: "interface",
      name: void 0,
      comment: getComment(this.context.checker, node),
      extends: [],
      props: this.getProps(node.members),
      types: []
    };
  }
  getExpressionWithTypeArguments(node) {
    const decl = getDeclarationFromNode(this.context.checker, node.expression);
    if (decl) {
      this.enqueue(decl);
      return getRef(this.normalizeName(decl), this.getTypeArguments(node.typeArguments));
    }
    return {
      kind: "ref",
      refName: "any",
      types: []
    };
  }
  getArray(node) {
    return getRef("Array", [this.getTypeNode(node.elementType)]);
  }
  getInfer(node) {
    return {
      kind: "infer",
      parameter: this.getTypeParameter(node.typeParameter)
    };
  }
  getIntersection(node) {
    return {
      kind: "intersection",
      types: node.types.map((n) => this.getTypeNode(n))
    };
  }
  getTuple(node) {
    return {
      kind: "tuple",
      types: (node["elementTypes"] ?? node.elements).map((n) => this.getTypeNode(n))
    };
  }
  getParenthesis(node) {
    return {
      kind: "parenthesis",
      value: this.getTypeNode(node.type)
    };
  }
  getTypeQueryNode(node) {
    const symbol = this.context.checker.getSymbolAtLocation(node.exprName);
    if (symbol !== void 0) {
      const exports2 = this.context.checker.getExportsOfModule(node.getSourceFile().symbol);
      if (!exports2.find((m) => m.name === symbol.name)) {
        const type = this.context.checker.getTypeOfSymbolAtLocation(symbol, node);
        const typeNode = this.convertToTypeNodeFromType(type);
        if (typeNode && ts4.isImportTypeNode(typeNode)) {
          const props = type.getProperties().map((prop) => ({
            name: prop.name,
            decl: prop.valueDeclaration
          })).map((m) => ({
            name: m.name,
            type: m.decl && this.context.checker.getTypeOfSymbolAtLocation(m.decl.symbol, m.decl)
          })).map((m) => ({
            name: m.name,
            node: m.type && this.convertToTypeNodeFromType(m.type)
          })).map(
            (m) => ({
              name: m.name,
              modifiers: "",
              optional: false,
              kind: "prop",
              valueType: this.getTypeNode(m.node)
            })
          );
          return {
            kind: "interface",
            props,
            types: [],
            extends: [],
            name: ""
          };
        }
        return this.getTypeNode(typeNode);
      }
    }
    const decl = getDeclarationFromNode(this.context.checker, node.exprName);
    this.enqueue(decl);
    return getRef(`typeof ${getTypeRefName(node.exprName)}`);
  }
  getTypeRestNode(node) {
    return {
      kind: "rest",
      value: this.getTypeNode(node.type)
    };
  }
  getNamedTuple(node) {
    const model = {
      kind: "tuple-prop",
      name: this.getPropName(node.name),
      valueType: this.getTypeNode(node.type),
      optional: node.questionToken !== void 0
    };
    if (node.dotDotDotToken) {
      return {
        kind: "rest",
        value: model
      };
    }
    return model;
  }
  getTemplateLiteralNode(node) {
    const parts = [node.head.text];
    for (const span of node.templateSpans) {
      parts.push(this.getTypeNode(span.type));
      parts.push(span.literal.text);
    }
    return {
      kind: "template",
      parts
    };
  }
  getConstantNode(node) {
    switch (node.kind) {
      case ts4.SyntaxKind.AnyKeyword:
        return {
          kind: "any"
        };
      case ts4.SyntaxKind.UnknownKeyword:
        return {
          kind: "unknown"
        };
      case ts4.SyntaxKind.NumberKeyword:
        return {
          kind: "number"
        };
      case ts4.SyntaxKind.BigIntKeyword:
        return {
          kind: "bigint"
        };
      case ts4.SyntaxKind.ObjectKeyword:
        return {
          kind: "nonPrimitive"
        };
      case ts4.SyntaxKind.BooleanKeyword:
        return {
          kind: "boolean"
        };
      case ts4.SyntaxKind.StringKeyword:
        return {
          kind: "string"
        };
      case ts4.SyntaxKind.SymbolKeyword:
        return {
          kind: "esSymbol"
        };
      case ts4.SyntaxKind.VoidKeyword:
        return {
          kind: "void"
        };
      case ts4.SyntaxKind.UndefinedKeyword:
        return {
          kind: "undefined"
        };
      case ts4.SyntaxKind.NullKeyword:
        return {
          kind: "null"
        };
      case ts4.SyntaxKind.NeverKeyword:
        return {
          kind: "never"
        };
      case ts4.SyntaxKind.ThisKeyword:
      case ts4.SyntaxKind.ThisType:
        return getRef("this");
      case ts4.SyntaxKind.ImportType:
        return this.resolveImport(node);
    }
    this.printWarning("type node", node);
  }
  resolveImport(node) {
    if (!ts4.isImportTypeNode(node)) {
      return {
        kind: "any"
      };
    } else if ("type" in node.parent) {
      const type = this.convertToTypeNodeFromNode(node.parent);
      return this.getTypeNode(type);
    } else if (node.qualifier) {
      const decl = getDeclarationFromNode(this.context.checker, node.qualifier);
      const type = this.convertToTypeNodeFromNode(decl);
      return this.getTypeNode(type);
    } else {
      return {
        kind: "import",
        value: this.getTypeNode(node.argument)
      };
    }
  }
  getTypeNode(node) {
    if (!node) {
      return {
        kind: "any"
      };
    } else if (ts4.isUnionTypeNode(node)) {
      return this.getUnion(node);
    } else if (ts4.isLiteralTypeNode(node)) {
      return this.getLiteral(node);
    } else if (ts4.isExpressionWithTypeArguments(node)) {
      return this.getExpressionWithTypeArguments(node);
    } else if (ts4.isTypeLiteralNode(node)) {
      return this.getTypeLiteral(node);
    } else if (ts4.isArrayTypeNode(node)) {
      return this.getArray(node);
    } else if (ts4.isTypeReferenceNode(node)) {
      return this.getTypeReference(node);
    } else if (ts4.isIndexedAccessTypeNode(node)) {
      return this.getIndexAccess(node);
    } else if (ts4.isTypeOperatorNode(node)) {
      return this.getTypeOperator(node);
    } else if (ts4.isMappedTypeNode(node)) {
      return this.getMappedType(node);
    } else if ("isConditionalTypeNode" in ts4 && ts4.isConditionalTypeNode(node)) {
      return this.getConditionalType(node);
    } else if (ts4.isFunctionTypeNode(node)) {
      return this.getMethodSignature(node);
    } else if ("isInferTypeNode" in ts4 && ts4.isInferTypeNode(node)) {
      return this.getInfer(node);
    } else if (ts4.isIntersectionTypeNode(node)) {
      return this.getIntersection(node);
    } else if (ts4.isParenthesizedTypeNode(node)) {
      return this.getParenthesis(node);
    } else if (ts4.isConstructorTypeNode(node)) {
      return this.getConstructorCall(node);
    } else if ("isTypePredicateNode" in ts4 && ts4.isTypePredicateNode(node)) {
      return this.getPredicate(node);
    } else if ("isTupleTypeNode" in ts4 && ts4.isTupleTypeNode(node)) {
      return this.getTuple(node);
    } else if ("isTypeQueryNode" in ts4 && ts4.isTypeQueryNode(node)) {
      return this.getTypeQueryNode(node);
    } else if ("isRestTypeNode" in ts4 && ts4.isRestTypeNode(node)) {
      return this.getTypeRestNode(node);
    } else if ("isTemplateLiteralTypeNode" in ts4 && ts4.isTemplateLiteralTypeNode(node)) {
      return this.getTemplateLiteralNode(node);
    } else if (ts4.isNamedTupleMember(node)) {
      return this.getNamedTuple(node);
    } else {
      return this.getConstantNode(node);
    }
  }
  getExtends(nodes) {
    const clauses = [];
    nodes?.forEach((node) => {
      if (node.token === ts4.SyntaxKind.ExtendsKeyword) {
        clauses.push(...node.types);
      } else {
        this.logVerbose(`Skipping unidentified node of kind "${node.kind}" in extends section.`);
      }
    });
    return clauses.map((node) => this.getTypeNode(node));
  }
  getImplements(nodes) {
    const clauses = [];
    nodes?.forEach((node) => {
      if (node.token === ts4.SyntaxKind.ImplementsKeyword) {
        clauses.push(...node.types);
      } else {
        this.logVerbose(`Skipping unidentified node of kind "${node.kind}" in implements section.`);
      }
    });
    return clauses.map((node) => this.getTypeNode(node));
  }
  getDefaultExpression(node) {
    const name = getExportName(node.name) ?? "_default";
    const expr = node.expression;
    if (ts4.isIdentifier(expr)) {
      const decl = getDeclarationFromNode(this.context.checker, expr);
      this.enqueue(decl);
      return getRef(expr.text);
    } else if (ts4.isArrowFunction(expr)) {
      this.includeInContext(expr, () => ({
        ...this.getMethodSignature(expr),
        name
      }));
    } else {
      this.includeInContext(expr, () => ({
        kind: "const",
        name,
        value: this.getExpression(expr),
        comment: getComment(this.context.checker, node)
      }));
    }
    return getRef(name);
  }
  getAlias(node) {
    const name = this.getName(node, node.name.text);
    return {
      kind: "alias",
      name,
      child: this.getTypeNode(node.type),
      types: this.getTypeParameters(node.typeParameters),
      comment: getComment(this.context.checker, node)
    };
  }
  getClass(node) {
    const { checker } = this.context;
    const type = checker.getTypeAtLocation(node);
    const decls = type.symbol.declarations.filter(ts4.isInterfaceDeclaration);
    const name = this.getName(node, node.name?.text);
    const docs = getAllJsDocs(checker, decls);
    decls.forEach((m) => this.enqueue(m));
    return {
      kind: "class",
      name,
      extends: this.getExtends(node.heritageClauses),
      implements: this.getImplements(node.heritageClauses),
      props: this.getClassMembers(node.members),
      types: this.getTypeParameters(node.typeParameters),
      comment: stringifyJsDocs(docs)
    };
  }
  getPropName(name) {
    if (!name) {
      return void 0;
    } else if (ts4.isIdentifier(name)) {
      return name.text;
    } else if (ts4.isStringLiteral(name)) {
      return name.text;
    } else if (ts4.isNumericLiteral(name)) {
      return name.text;
    } else if (ts4.isComputedPropertyName(name)) {
      return this.getExpression(name.expression);
    } else {
      return name.getText();
    }
  }
  getInterface(node) {
    const { checker, availableImports, root } = this.context;
    const type = checker.getTypeAtLocation(node);
    const decls = type.symbol.declarations.filter(ts4.isInterfaceDeclaration).filter((m) => !isImportedFile(m, root, availableImports));
    const clauses = [];
    const props = [];
    const typeParameters = [];
    const name = this.getName(node, node.name.text);
    const docs = getAllJsDocs(checker, decls);
    decls.forEach((m) => {
      m.heritageClauses?.forEach((c) => {
        clauses.includes(c) || includeClauses(this.context, clauses, c, docs.tags);
      });
      m.members?.forEach((p) => {
        props.includes(p) || includeProp(props, p, (prop) => this.getPropName(prop), docs.tags);
      });
      m.typeParameters?.forEach((t, i) => {
        typeParameters.length === i && typeParameters.push(t);
      });
    });
    return {
      kind: "interface",
      name,
      extends: this.getExtends(clauses),
      props: this.getProps(props),
      types: this.getTypeParameters(typeParameters),
      comment: stringifyJsDocs(docs)
    };
  }
  getExpression(node) {
    if (ts4.isArrowFunction(node)) {
      const typeNode = this.convertToTypeNodeFromNode(node);
      if (ts4.isFunctionTypeNode(typeNode)) {
        return this.getMethodSignature(node);
      }
      return this.getTypeNode(typeNode);
    } else if (ts4.isNumericLiteral(node)) {
      return {
        kind: "literal",
        value: node.text
      };
    } else if (ts4.isStringLiteral(node)) {
      return {
        kind: "literal",
        value: JSON.stringify(node.text)
      };
    } else if (node.kind === ts4.SyntaxKind.TrueKeyword || node.kind === ts4.SyntaxKind.FalseKeyword) {
      return {
        kind: "boolean"
      };
    } else if (ts4.isIdentifier(node)) {
      const decl = getDeclarationFromNode(this.context.checker, node);
      this.enqueue(decl);
      return getRef(node.text);
    } else if (ts4.isPropertyAccessExpression(node)) {
      return {
        kind: "access",
        object: this.getExpression(node.expression),
        name: this.getExpression(node.name)
      };
    } else {
      return this.getInferredType(node);
    }
  }
  getVariableValue(node) {
    if (node.type) {
      return this.getTypeNode(node.type);
    } else if (node.initializer) {
      return this.getExpression(node.initializer);
    } else {
      const typeNode = this.convertToTypeNodeFromNode(node);
      return this.getTypeNode(typeNode);
    }
  }
  getVariable(node) {
    const name = this.getName(node, node.name.getText());
    return {
      kind: "const",
      name,
      value: this.getVariableValue(node),
      comment: getComment(this.context.checker, node)
    };
  }
  getEnum(node) {
    const symbol = getSymbol(this.context.checker, node);
    const name = this.getName(node, node.name.text);
    return {
      kind: "enumLiteral",
      name,
      const: symbol.flags === ts4.SymbolFlags.ConstEnum,
      values: this.getEnumMembers(node.members),
      comment: getComment(this.context.checker, node)
    };
  }
  includeInContext(node, createType) {
    const c = this.context;
    const symbol = getSymbol(c.checker, node);
    const { external, fn } = getPackage(node, symbol, c.root, c.availableImports);
    if (!external) {
      this.refs.push(createType());
    } else {
      this.logVerbose(`Node from "${fn}" is external and should not be included.`);
    }
  }
  includeExportedTypeAlias(node) {
    this.includeInContext(node, () => this.getAlias(node));
  }
  includeDefaultExport(node) {
    const expr = node.expression;
    if (expr) {
      this.includeInContext(expr, () => getDefault(this.getDefaultExpression(node)));
    } else if (ts4.isFunctionDeclaration(node)) {
      const name = "_default";
      this.includeInContext(node, () => ({
        ...this.getMethodSignature(node),
        name
      }));
      this.includeInContext(node, () => getDefault(getRef(name)));
    } else if (ts4.isClassDeclaration(node)) {
      this.includeInContext(node, () => getDefault(this.getClass(node)));
    } else {
      this.printWarning("default export", node);
    }
  }
  includeExportedFunction(node) {
    this.includeInContext(node, () => this.getFunctionDeclaration(node));
  }
  includeExportedClass(node) {
    this.includeInContext(node, () => this.getClass(node));
  }
  includeExportedInterface(node) {
    const name = this.getName(node, node.name.text);
    const exists = this.refs.some((m) => m.kind === "interface" && m.name === name);
    if (!exists) {
      this.includeInContext(node, () => this.getInterface(node));
    } else {
      this.logVerbose(`Skipping already included interface "${name}".`);
    }
  }
  includeExportedVariable(node) {
    this.includeInContext(node, () => this.getVariable(node));
  }
  includeExportedVariables(node) {
    node.declarationList.declarations.forEach((decl) => this.includeExportedVariable(decl));
  }
  includeImportedValue(node) {
    const decl = node.symbol.declarations[0];
    this.enqueue(decl);
  }
  includeExportedEnum(node) {
    this.includeInContext(node, () => this.getEnum(node));
  }
  includeSelectedExports(elements) {
    elements.forEach((el) => {
      if (el.symbol) {
        const original = this.context.checker.getAliasedSymbol(el.symbol);
        if (original) {
          const decl = getDeclarationFromSymbol(this.context.checker, original);
          if (decl) {
            this.processNode(decl);
            this.swapName(original.name, el.symbol.name);
          }
        } else if (el.propertyName) {
          const symbol = this.context.checker.getExportSpecifierLocalTargetSymbol(el);
          if (symbol) {
            const decl = getDeclarationFromSymbol(this.context.checker, symbol);
            if (decl) {
              this.processNode(decl);
              this.swapName(el.propertyName.text, el.symbol.name);
            }
          }
        }
      }
    });
  }
  includeStarExports(node) {
    if (node.moduleSpecifier && ts4.isStringLiteral(node.moduleSpecifier)) {
      const moduleName = node.moduleSpecifier.text;
      const sourceFile = node.getSourceFile();
      this.context.forEachResolvedModule((value, originalName) => {
        if (originalName === moduleName) {
          const fileName = value?.resolvedModule?.resolvedFileName ?? value?.resolvedFileName;
          if (fileName) {
            const newFile = this.context.program.getSourceFile(fileName);
            ts4.forEachChild(newFile, (node2) => {
              if (shouldInclude(node2)) {
                this.enqueue(node2);
              }
            });
          }
        }
      }, sourceFile);
    }
  }
  includeExportsDeclaration(node) {
    const { exportClause } = node;
    if (exportClause && ts4.isNamedExports(exportClause) && exportClause.elements) {
      this.includeSelectedExports(exportClause.elements);
    } else {
      this.includeStarExports(node);
    }
  }
  processModule(node) {
    const c = this.context;
    const name = node.name.text;
    const availableImportNames = Object.keys(this.context.availableImports);
    c.modules[name] = this.refs = c.modules[name] || [];
    c.moduleNames[name] = this.names = c.moduleNames[name] || /* @__PURE__ */ new Map();
    node.body?.forEachChild((subNode) => {
      if (isNodeExported(subNode) || availableImportNames.includes(name)) {
        this.enqueue(subNode);
      }
    });
  }
  processNode(node) {
    this.processed.push(node);
    if (ts4.isTypeAliasDeclaration(node)) {
      this.includeExportedTypeAlias(node);
    } else if (isDefaultExport(node)) {
      this.includeDefaultExport(node);
    } else if (ts4.isVariableDeclaration(node)) {
      this.includeExportedVariable(node);
    } else if (ts4.isVariableStatement(node)) {
      this.includeExportedVariables(node);
    } else if (ts4.isFunctionDeclaration(node)) {
      this.includeExportedFunction(node);
    } else if (ts4.isInterfaceDeclaration(node)) {
      this.includeExportedInterface(node);
    } else if (ts4.isClassDeclaration(node)) {
      this.includeExportedClass(node);
    } else if (ts4.isImportSpecifier(node)) {
      this.includeImportedValue(node);
    } else if (ts4.isEnumDeclaration(node)) {
      this.includeExportedEnum(node);
    } else if (ts4.isTypeLiteralNode(node)) {
      this.logVerbose(`Skipping type literal node: ${node}`);
    } else if (ts4.isExportDeclaration(node)) {
      this.includeExportsDeclaration(node);
    } else if (ts4.isModuleDeclaration(node)) {
      this.modules.push(node);
    } else if (ts4.isImportTypeNode(node) || ts4.isPropertySignature(node) || ts4.isPropertyAssignment(node)) {
      this.logVerbose(`Skipping import type node: ${node}`);
    } else {
      this.printWarning("type", node);
    }
  }
  enqueue(item) {
    if (!item) {
    } else if (ts4.isEnumMember(item)) {
      this.enqueue(item.parent);
    } else if (!this.queue.includes(item) && !this.processed.includes(item)) {
      this.queue.push(item);
    }
  }
  processQueue() {
    while (this.queue.length || this.modules.length) {
      while (this.queue.length > 0) {
        const item = this.queue.shift();
        this.processNode(item);
      }
      if (this.modules.length > 0) {
        const mod = this.modules.shift();
        this.processModule(mod);
      }
    }
  }
};

// src/input/typings.ts
function includeTypings(context, node) {
  if (shouldInclude(node)) {
    context.exports.push(node);
  } else {
    context.log.verbose(`Skipping typings from node: ${node}`);
  }
}

// src/commands.ts
function setupVisitorContext(name, root, files, imports, log, flags) {
  const rootNames = files.filter((m) => !!m);
  const [major, minor] = ts5.versionMajorMinor.split(".").map((x) => Number(x));
  const supportsBundler = major === 5 && minor >= 3 || major > 5;
  const program = ts5.createProgram(rootNames, {
    allowJs: true,
    esModuleInterop: true,
    module: ts5.ModuleKind.ESNext,
    moduleResolution: supportsBundler ? ts5.ModuleResolutionKind.Bundler : ts5.ModuleResolutionKind.Node10,
    jsx: ts5.JsxEmit.React
  });
  const checker = program.getTypeChecker();
  const context = {
    modules: {
      [name]: []
    },
    moduleNames: {
      [name]: /* @__PURE__ */ new Map()
    },
    availableImports: {},
    usedImports: [],
    imports,
    exports: [],
    root,
    name,
    checker,
    program,
    log,
    flags,
    forEachResolvedModule(cb, file) {
      if ("forEachResolvedModule" in program) {
        context.program.forEachResolvedModule(cb, file);
      } else {
        file.resolvedModules?.forEach(cb);
      }
    }
  };
  addAvailableImports(context, imports);
  addAmbientModules(context, imports);
  return context;
}
function fillExportsFromApi(context, apiPath, apiName) {
  const api = context.program.getSourceFile(apiPath);
  if (api) {
    ts5.forEachChild(api, (node) => includeApi(context, node, apiName));
  } else {
    context.log.error(
      `Cannot find the "${apiPath}" module. Are you sure it exists? Please run "npm i" to install missing modules.`
    );
  }
}
function fillExportsFromReferences(context, typingsPath) {
  const tp = context.program.getSourceFile(typingsPath);
  if (tp) {
    const ps = tp.pragmas?.get("reference");
    if (ps) {
      const values = Array.isArray(ps) ? ps.map((m) => m.arguments?.path?.value) : [ps.arguments?.path?.value];
      values.forEach((value) => {
        if (typeof value === "string") {
          const path = (0, import_path3.resolve)(typingsPath, "..", value);
          fillExportsFromTypes(context, path);
        }
      });
    }
  }
}
function fillExportsFromTypes(context, typingsPath) {
  const tp = context.program.getSourceFile(typingsPath);
  if (tp) {
    fillExportsFromReferences(context, typingsPath);
    ts5.forEachChild(tp, (node) => includeTypings(context, node));
  } else {
    context.log.warn(
      'Cannot find the provided typings. Check the "typings" field of your "package.json" for the correct path.'
    );
  }
}
function addAvailableImports(context, imports) {
  const sourceFiles = context.program.getSourceFiles();
  const remaining = [...imports];
  context.log.verbose(`Adding ${imports.length} imports from ${sourceFiles.length} source files.`);
  for (const sourceFile of sourceFiles) {
    if (remaining.length === 0) {
      break;
    }
    context.forEachResolvedModule((value, key) => {
      const index = remaining.indexOf(key);
      const fileName = value?.resolvedModule?.resolvedFileName ?? value?.resolvedFileName;
      if (!fileName) {
        context.log.verbose(`Skipping module without filename: ${value}.`);
      } else if (index === -1) {
        context.log.verbose(`Skipping module "${fileName}" as it does not match.`);
      } else {
        const file = context.program.getSourceFile(fileName);
        includeExports(context, key, file?.symbol);
        remaining.splice(index, 1);
      }
    }, sourceFile);
  }
}
function addAmbientModules(context, imports) {
  const modules = context.checker.getAmbientModules();
  context.log.verbose(`Adding ${modules.length} ambient modules.`);
  for (const module2 of modules) {
    const file = module2.declarations?.[0]?.getSourceFile()?.fileName;
    const lib = getLibName(file, context.root);
    if (imports.includes(lib)) {
      includeExports(context, module2.name, module2);
    }
  }
}
async function runAll(context, plugins, type) {
  const { log } = context;
  log.verbose(`Running the ${type}" plugins.`);
  for (const plugin of plugins) {
    try {
      if ("type" in plugin) {
        if (plugin.type === type) {
          await plugin.run(context);
        }
      } else if (typeof plugin[type] === "function") {
        const runner = plugin[type];
        await runner.call(plugin, context);
      }
    } catch (ex) {
      log.error(`The plugin "${plugin.name}" crashed: ${ex}`);
    }
  }
}
async function processVisitorContext(context, plugins) {
  const { log } = context;
  await runAll(context, plugins, "before-init");
  const visitor = new DeclVisitor(context);
  await runAll(context, plugins, "before-process");
  log.verbose("Processing the queue.");
  visitor.processQueue();
  await runAll(context, plugins, "after-process");
  await runAll(context, plugins, "before-stringify");
  log.verbose("Generating the string representation.");
}
async function generateDeclaration(options) {
  const {
    name,
    root = process.cwd(),
    imports = [],
    files = [],
    types = [],
    apis = [],
    plugins = [],
    logger = defaultLogger,
    logLevel = 3,
    noIgnore = false,
    noModuleDeclaration = false
  } = options;
  const log = wrapLogger(logger, logLevel);
  log.verbose(`Aggregating the sources from "${root}".`);
  const sources = [
    ...files.map((file) => findAppRoot(root, file)),
    ...apis.map((api) => findAppRoot(root, api.file)),
    ...types.map((type) => findAppRoot(root, type))
  ];
  log.verbose(`Setting up a visitor context for "${name}".`);
  const context = setupVisitorContext(name, root, sources, imports, log, {
    noIgnore,
    noModuleDeclaration
  });
  log.verbose(`Starting API gathering in "${root}".`);
  for (const api of apis) {
    const path = findAppRoot(root, api.file);
    fillExportsFromApi(context, path, api.name);
  }
  log.verbose(`Starting type aggregation from "${root}".`);
  for (const type of types) {
    const path = findAppRoot(root, type);
    fillExportsFromTypes(context, path);
  }
  log.verbose(`Processing the visitor context.`);
  await processVisitorContext(context, plugins);
  return stringifyDeclaration(context);
}
async function retrieveTypings(options) {
  const name = "main";
  const {
    root = process.cwd(),
    imports = [],
    files = [],
    types = [],
    plugins = [],
    logger = defaultLogger,
    logLevel = 3,
    noIgnore = false,
    noModuleDeclaration = false
  } = options;
  const log = wrapLogger(logger, logLevel);
  log.verbose(`Aggregating the sources from "${root}".`);
  const sources = [...files.map((file) => findAppRoot(root, file)), ...types.map((type) => findAppRoot(root, type))];
  log.verbose(`Setting up a visitor context for "${name}".`);
  const context = setupVisitorContext(name, root, sources, imports, log, {
    noIgnore,
    noModuleDeclaration
  });
  log.verbose(`Starting type aggregation from "${root}".`);
  for (const type of types) {
    const path = findAppRoot(root, type);
    fillExportsFromTypes(context, path);
  }
  log.verbose(`Processing the visitor context.`);
  await processVisitorContext(context, plugins);
  return context.modules.main;
}

// src/plugins.ts
var import_path4 = require("path");

// src/refs.ts
function findRefs(types) {
  const queue = [...types];
  const refs = [];
  for (let i = 0; i < queue.length; i++) {
    const type = queue[i];
    switch (type?.kind) {
      case "ref":
        refs.push(type);
        break;
      case "alias":
        queue.push(type.child, ...type.types);
        break;
      case "function":
        queue.push(...type.parameters, type.returnType, ...type.types);
        break;
      case "default":
        queue.push(type.value);
        break;
      case "const":
        queue.push(type.value);
        break;
      case "interface":
        queue.push(...type.extends, type.mapped, ...type.props, ...type.types);
        break;
      case "class":
        queue.push(...type.extends, ...type.implements, ...type.props, ...type.types);
        break;
      case "enumLiteral":
        queue.push(...type.values);
        break;
      case "member":
        queue.push(type.value);
        break;
      case "prop":
        queue.push(type.valueType);
        break;
      case "typeParameter":
        queue.push(type.constraint, type.parameter);
        break;
      case "parameter":
        queue.push(type.value);
        break;
      case "union":
        queue.push(...type.types);
        break;
      case "intersection":
        queue.push(...type.types);
        break;
      case "index":
        queue.push(type.valueType, ...type.parameters);
        break;
      case "indexedAccess":
        queue.push(type.index, type.object);
        break;
      case "conditional":
        queue.push(type.alternate, type.check, type.extends, type.primary);
        break;
      case "substitution":
        queue.push(type.variable);
        break;
      case "tuple-prop":
        queue.push(type.valueType);
        break;
      case "tuple":
        queue.push(...type.types);
        break;
      case "constructor":
        queue.push(...type.parameters);
        break;
      case "keyof":
        queue.push(type.value);
        break;
      case "readonly":
        queue.push(type.value);
        break;
      case "unique":
        queue.push(type.value);
        break;
      case "predicate":
        queue.push(type.value);
        break;
      case "mapped":
        queue.push(type.constraint, type.value);
        break;
      case "infer":
        queue.push(type.parameter);
        break;
      case "new":
        queue.push(...type.parameters, type.returnType, ...type.types);
        break;
      case "get":
        queue.push(type.type);
        break;
      case "set":
        queue.push(...type.parameters);
        break;
      case "parenthesis":
        queue.push(type.value);
        break;
      case "rest":
        queue.push(type.value);
        break;
      case "template":
        queue.push(...type.parts.map((m) => typeof m !== "string" ? m : void 0).filter(Boolean));
        break;
      default:
        break;
    }
  }
  return refs;
}
function updateImports(imprts, refs) {
  for (let i = imprts.length; i--; ) {
    const refName = getLibRefName(imprts[i]);
    const prefix = `${refName}.`;
    const hasRef = refs.some((ref) => ref.refName.startsWith(prefix));
    if (!hasRef) {
      imprts.splice(i, 1);
    }
  }
}

// src/plugins.ts
function stringifyNodeInternal(node) {
  if (node.kind === "interface" || node.kind === "class") {
    return stringifyExport(node);
  }
  return stringifyNode(node);
}
function createExcludePlugin(moduleNames) {
  return {
    name: "exclude-plugin",
    "after-process"(context) {
      for (const name of moduleNames) {
        delete context.modules[name];
      }
    }
  };
}
function createDiffPlugin(originalFile) {
  const state = {};
  return {
    name: "diff-plugin",
    async "before-init"(context) {
      const refs = await retrieveTypings({
        root: (0, import_path4.dirname)(originalFile),
        types: [originalFile],
        plugins: [],
        logger: context.log,
        imports: context.imports,
        log: context.log
      });
      state.types = refs;
      state.cache = refs.map((ref) => stringifyNodeInternal(ref));
    },
    async "after-process"(context) {
      const mod = context.modules[context.name];
      for (let i = mod.length; i--; ) {
        const node = mod[i];
        const current = stringifyNodeInternal(node);
        if (state.cache.indexOf(current) !== -1) {
          mod.splice(i, 1);
        } else if (node.kind === "interface") {
          const mergedInterface = state.types.find((m) => m.kind === "interface" && m.name === node.name);
          if (mergedInterface) {
            const originals = mergedInterface.props.map((p) => stringifyNode(p));
            for (let j = node.props.length; j--; ) {
              const prop = stringifyNode(node.props[j]);
              if (originals.includes(prop)) {
                node.props.splice(j, 1);
              }
            }
          }
        }
      }
      const refs = findRefs(mod);
      updateImports(context.usedImports, refs);
    }
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  addAmbientModules,
  addAvailableImports,
  createDiffPlugin,
  createExcludePlugin,
  fillExportsFromApi,
  fillExportsFromReferences,
  fillExportsFromTypes,
  generateDeclaration,
  processVisitorContext,
  retrieveTypings,
  setupVisitorContext
});
