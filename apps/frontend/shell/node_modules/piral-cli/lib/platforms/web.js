"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setup = setup;
const kras_1 = require("kras");
const path_1 = require("path");
const injectors_1 = require("../common/injectors");
const log_1 = require("../common/log");
const config_1 = require("../common/config");
const browser_1 = require("../common/browser");
const io_1 = require("../common/io");
const port_1 = require("../common/port");
async function getPort(network) {
    if (network.type !== 'fixed') {
        const strict = network.type === 'wanted';
        network.port = await (0, port_1.getAvailablePort)(network.port, strict);
        network.type = 'fixed';
    }
    return network.port;
}
async function startModule(options) {
    const { appDir, fullBase, open, feed, publicUrl, customkrasrc, network, hooks, registerWatcher, registerEnd, pilets, maxListeners, } = options;
    const sources = pilets.map((m) => m.mocks).filter(Boolean);
    const api = `${publicUrl}${config_1.config.piletApi.replace(/^\/+/, '')}`;
    const baseMocks = (0, path_1.resolve)(fullBase, 'mocks');
    const initial = (0, injectors_1.createInitialKrasConfig)(baseMocks, sources, { [api]: '' }, feed);
    const configs = [...pilets.map((p) => (0, path_1.resolve)(p.root, kras_1.krasrc))];
    const required = {
        injectors: {
            piral: {
                active: false,
            },
            pilet: {
                active: true,
                pilets,
                app: appDir,
                publicUrl,
                handle: ['/', api],
                api,
            },
        },
    };
    if (appDir) {
        const appPackageJson = await (0, io_1.findFile)(appDir, 'package.json');
        if (appPackageJson) {
            configs.unshift((0, path_1.resolve)((0, path_1.dirname)(appPackageJson), kras_1.krasrc));
        }
    }
    configs.push((0, path_1.resolve)(process.cwd(), kras_1.krasrc));
    if (customkrasrc) {
        configs.push((0, path_1.resolve)(fullBase, customkrasrc));
    }
    configs.forEach(registerWatcher);
    const shouldNotify = network.type === 'proposed';
    const port = await getPort(network);
    const krasConfig = (0, kras_1.readKrasConfig)({ port, initial, required }, ...configs);
    (0, log_1.log)('generalVerbose_0004', `Using kras with configuration: ${JSON.stringify(krasConfig, undefined, 2)}`);
    const krasServer = (0, kras_1.buildKrasWithCli)(krasConfig);
    krasServer.setMaxListeners(maxListeners);
    krasServer.removeAllListeners('open');
    if (shouldNotify) {
        krasServer.on('open', (0, injectors_1.notifyServerOnline)(publicUrl, krasConfig.api));
    }
    await hooks.beforeOnline?.({ krasServer, krasConfig, open, port, api, feed, pilets, publicUrl });
    await krasServer.start();
    (0, browser_1.openBrowser)(open, port, publicUrl, !!krasConfig.ssl);
    await hooks.afterOnline?.({ krasServer, krasConfig, open, port, api, feed, pilets, publicUrl });
    registerEnd(() => krasServer.stop());
    return (options) => {
        const injector = krasServer.injectors.find((m) => m.name === 'pilet-injector');
        injector?.setOptions(options);
    };
}
async function startShell(options) {
    const { fullBase, open, root, targetDir, feed, publicUrl, bundler, customkrasrc, network, hooks, registerWatcher, registerEnd, } = options;
    const krasBaseConfig = (0, path_1.resolve)(fullBase, kras_1.krasrc);
    const krasRootConfig = (0, path_1.resolve)(root, kras_1.krasrc);
    const mocks = (0, path_1.join)(targetDir, 'mocks');
    const baseMocks = (0, path_1.resolve)(fullBase, 'mocks');
    const mocksExist = await (0, io_1.checkExistingDirectory)(mocks);
    const sources = [mocksExist ? mocks : undefined].filter(Boolean);
    const initial = (0, injectors_1.createInitialKrasConfig)(baseMocks, sources);
    const configs = [krasBaseConfig, krasRootConfig];
    const required = {
        injectors: {
            piral: {
                active: true,
                handle: ['/'],
                feed,
                publicUrl,
                bundler,
            },
            pilet: {
                active: false,
            },
        },
    };
    configs.push((0, path_1.resolve)(process.cwd(), kras_1.krasrc));
    if (customkrasrc) {
        configs.push((0, path_1.resolve)(fullBase, customkrasrc));
    }
    configs.forEach(registerWatcher);
    const shouldNotify = network.type === 'proposed';
    const port = await getPort(network);
    const krasConfig = (0, kras_1.readKrasConfig)({ port, initial, required }, ...configs);
    (0, log_1.log)('generalVerbose_0004', `Using kras with configuration: ${JSON.stringify(krasConfig, undefined, 2)}`);
    const krasServer = (0, kras_1.buildKrasWithCli)(krasConfig);
    krasServer.setMaxListeners(16);
    krasServer.removeAllListeners('open');
    if (shouldNotify) {
        krasServer.on('open', (0, injectors_1.notifyServerOnline)(publicUrl, krasConfig.api));
    }
    await hooks.beforeOnline?.({ krasServer, krasConfig, open, port, publicUrl });
    await krasServer.start();
    (0, browser_1.openBrowser)(open, port, publicUrl, !!krasConfig.ssl);
    await hooks.afterOnline?.({ krasServer, krasConfig, open, port, publicUrl });
    registerEnd(async () => krasServer.stop());
    return (options) => {
        const injector = krasServer.injectors.find((m) => m.name === 'piral-injector');
        injector?.setOptions(options);
    };
}
function setup() {
    return {
        startModule,
        startShell,
    };
}
//# sourceMappingURL=web.js.map