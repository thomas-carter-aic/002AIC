"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.declarationPiletDefaults = void 0;
exports.declarationPilet = declarationPilet;
const path_1 = require("path");
const types_1 = require("../types");
const common_1 = require("../common");
exports.declarationPiletDefaults = {
    entry: './',
    target: './dist',
    forceOverwrite: common_1.ForceOverwrite.yes,
    logLevel: types_1.LogLevels.info,
};
async function declarationPilet(baseDir = process.cwd(), options = {}) {
    const { entry = exports.declarationPiletDefaults.entry, target = exports.declarationPiletDefaults.target, forceOverwrite = exports.declarationPiletDefaults.forceOverwrite, logLevel = exports.declarationPiletDefaults.logLevel, } = options;
    (0, common_1.ensure)('baseDir', baseDir, 'string');
    (0, common_1.ensure)('entry', entry, 'string');
    (0, common_1.ensure)('target', target, 'string');
    const entryList = Array.isArray(entry) ? entry : [entry];
    const fullBase = (0, path_1.resolve)(process.cwd(), baseDir);
    (0, common_1.setLogLevel)(logLevel);
    const allEntries = await (0, common_1.matchAnyPilet)(fullBase, entryList);
    const results = [];
    for (const item of allEntries) {
        const targetDir = (0, path_1.dirname)(item);
        const { peerDependencies, peerModules, root, apps, importmap } = await (0, common_1.retrievePiletData)(targetDir);
        const piralInstances = apps.map((m) => m.appPackage.name);
        const externals = (0, common_1.combinePiletExternals)(piralInstances, peerDependencies, peerModules, importmap);
        const dest = (0, path_1.resolve)(root, target);
        results.push(await (0, common_1.createPiletDeclaration)(piralInstances, root, item, externals, dest, forceOverwrite, logLevel));
    }
    if (results.every(Boolean)) {
        (0, common_1.logDone)(`Declaration created successfully in "${target}"!`);
    }
}
//# sourceMappingURL=declaration-pilet.js.map