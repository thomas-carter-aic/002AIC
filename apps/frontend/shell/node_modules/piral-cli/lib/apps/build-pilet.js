"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildPiletDefaults = void 0;
exports.buildPilet = buildPilet;
const path_1 = require("path");
const types_1 = require("../types");
const bundler_1 = require("../bundler");
const common_1 = require("../common");
function createMetadata(outDir, outFile, pilets, publicPath) {
    return (0, common_1.writeJson)(outDir, outFile, pilets.map((p) => ({
        name: p.package.name,
        version: p.package.version,
        link: `${publicPath}${p.id}/${p.outFile}`,
        ...(0, common_1.getPiletSpecMeta)(p.path, `${publicPath}${p.id}/`),
    })));
}
function copyPilets(outDir, pilets) {
    return Promise.all(pilets.map(async (p) => {
        const files = await (0, common_1.getFileNames)(p.outDir);
        for (const file of files) {
            await (0, common_1.copy)((0, path_1.resolve)(p.outDir, file), (0, path_1.resolve)(outDir, p.id, file), common_1.ForceOverwrite.yes);
        }
    }));
}
exports.buildPiletDefaults = {
    entry: './src/index',
    target: './dist/index.js',
    publicUrl: '/',
    minify: true,
    logLevel: types_1.LogLevels.info,
    type: 'default',
    fresh: false,
    sourceMaps: true,
    watch: false,
    contentHash: true,
    optimizeModules: false,
    schemaVersion: undefined,
    concurrency: common_1.cpuCount,
    declaration: true,
};
async function buildPilet(baseDir = process.cwd(), options = {}) {
    const { entry = exports.buildPiletDefaults.entry, target = exports.buildPiletDefaults.target, publicUrl: originalPublicUrl = exports.buildPiletDefaults.publicUrl, logLevel = exports.buildPiletDefaults.logLevel, minify = exports.buildPiletDefaults.minify, sourceMaps = exports.buildPiletDefaults.sourceMaps, watch = exports.buildPiletDefaults.watch, contentHash = exports.buildPiletDefaults.contentHash, fresh = exports.buildPiletDefaults.fresh, concurrency = exports.buildPiletDefaults.concurrency, optimizeModules = exports.buildPiletDefaults.optimizeModules, schemaVersion: originalSchemaVersion = exports.buildPiletDefaults.schemaVersion, declaration = exports.buildPiletDefaults.declaration, type = exports.buildPiletDefaults.type, _ = {}, hooks = {}, bundlerName, app, } = options;
    (0, common_1.ensure)('baseDir', baseDir, 'string');
    (0, common_1.ensure)('publicUrl', originalPublicUrl, 'string');
    (0, common_1.ensure)('entry', entry, 'string');
    (0, common_1.ensure)('_', _, 'object');
    (0, common_1.ensure)('hooks', hooks, 'object');
    (0, common_1.ensure)('target', target, 'string');
    const publicUrl = (0, common_1.normalizePublicUrl)(originalPublicUrl);
    const fullBase = (0, path_1.resolve)(process.cwd(), baseDir);
    const entryList = Array.isArray(entry) ? entry : [entry];
    const manifest = 'pilets.json';
    (0, common_1.setLogLevel)(logLevel);
    await hooks.onBegin?.({ options, fullBase });
    (0, common_1.progress)('Reading configuration ...');
    const allEntries = await (0, common_1.matchAnyPilet)(fullBase, entryList);
    (0, common_1.log)('generalDebug_0003', `Found the following entries: ${allEntries.join(', ')}`);
    if (allEntries.length === 0) {
        (0, common_1.fail)('entryFileMissing_0077');
    }
    const pilets = await (0, common_1.concurrentWorkers)(allEntries, concurrency, async (entryModule) => {
        const { piletPackage, root, outDir, apps, outFile, dest } = await (0, common_1.triggerBuildPilet)({
            _,
            app,
            bundlerName,
            contentHash,
            entryModule,
            fresh,
            logLevel,
            minify,
            optimizeModules,
            originalSchemaVersion,
            sourceMaps,
            target,
            watch,
            hooks,
            declaration,
        });
        (0, common_1.logDone)(`Pilet "${piletPackage.name}" built successfully!`);
        return {
            id: piletPackage.name.replace(/[^a-zA-Z0-9\-]/gi, ''),
            root,
            apps,
            outDir,
            outFile,
            path: dest,
            package: piletPackage,
        };
    });
    if (type === 'standalone') {
        const distDir = (0, path_1.dirname)((0, path_1.resolve)(fullBase, target));
        const outDir = (0, path_1.resolve)(distDir, 'standalone');
        const outFile = 'index.html';
        const { apps, root } = pilets[0];
        if (apps.length === 0) {
            (0, common_1.fail)('appInstancesNotGiven_0012');
        }
        const { appPackage, appFile } = apps[0];
        const piralInstances = [appPackage.name];
        const isEmulator = (0, common_1.checkAppShellPackage)(appPackage);
        (0, common_1.logInfo)('Building standalone solution ...');
        await (0, common_1.removeDirectory)(outDir);
        (0, common_1.progress)('Copying files ...');
        await copyPilets(outDir, pilets);
        await createMetadata(outDir, manifest, pilets, publicUrl);
        if (isEmulator) {
            // in case of an emulator assets are not "seen" by the bundler, so we
            // just copy overthing over - this should work in most cases.
            await (0, common_1.copy)((0, path_1.dirname)(appFile), outDir, common_1.ForceOverwrite.yes);
            (0, common_1.progress)('Optimizing app shell ...');
            // we don't need to care about externals or other things that are already
            // part of the emulator
            await (0, bundler_1.callPiralBuild)({
                root,
                piralInstances,
                emulator: false,
                standalone: true,
                optimizeModules: false,
                sourceMaps,
                watch: false,
                contentHash,
                minify,
                externals: [],
                publicUrl,
                outFile,
                outDir,
                entryFiles: appFile,
                logLevel,
                ignored: [],
                _,
            }, bundlerName);
        }
        else {
            // in this case we can just do the same steps as if
            const { ignored, externals } = await (0, common_1.retrievePiletsInfo)(appFile);
            await (0, bundler_1.callPiralBuild)({
                root,
                piralInstances,
                emulator: false,
                standalone: true,
                optimizeModules: false,
                sourceMaps,
                watch: false,
                contentHash,
                minify,
                externals: (0, common_1.flattenExternals)(externals),
                publicUrl,
                outFile,
                outDir,
                entryFiles: appFile,
                logLevel,
                ignored,
                _,
            }, bundlerName);
        }
        const html = await (0, common_1.readText)(outDir, outFile);
        const newHtml = html.replace('<script', // place the assignment before the first seen script
        `<script>window['dbg:pilet-api']=${JSON.stringify(publicUrl + manifest)};</script><script`);
        await (0, common_1.writeText)(outDir, outFile, newHtml);
        (0, common_1.logDone)(`Standalone app available at "${outDir}"!`);
    }
    else if (type === 'manifest') {
        const outDir = (0, path_1.dirname)((0, path_1.resolve)(fullBase, target));
        (0, common_1.logInfo)('Building pilet manifest ...');
        (0, common_1.progress)('Copying files ...');
        await copyPilets(outDir, pilets);
        await createMetadata(outDir, manifest, pilets, publicUrl);
        (0, common_1.logDone)(`Manifest available at "${outDir}/${manifest}"!`);
    }
    await hooks.onEnd?.({});
}
//# sourceMappingURL=build-pilet.js.map