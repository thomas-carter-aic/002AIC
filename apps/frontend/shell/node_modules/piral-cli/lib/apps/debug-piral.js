"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.debugPiralDefaults = void 0;
exports.debugPiral = debugPiral;
const path_1 = require("path");
const bundler_1 = require("../bundler");
const types_1 = require("../types");
const common_1 = require("../common");
exports.debugPiralDefaults = {
    entry: './',
    target: './dist',
    port: common_1.config.port,
    strictPort: common_1.config.strictPort,
    publicUrl: '/',
    logLevel: types_1.LogLevels.info,
    open: common_1.config.openBrowser,
    hmr: true,
    krasrc: undefined,
    optimizeModules: false,
};
async function debugPiral(baseDir = process.cwd(), options = {}) {
    const { entry = exports.debugPiralDefaults.entry, target = exports.debugPiralDefaults.target, open = exports.debugPiralDefaults.open, hmr = exports.debugPiralDefaults.hmr, port: originalPort = exports.debugPiralDefaults.port, strictPort = exports.debugPiralDefaults.strictPort, publicUrl: originalPublicUrl = exports.debugPiralDefaults.publicUrl, logLevel = exports.debugPiralDefaults.logLevel, krasrc: customkrasrc = exports.debugPiralDefaults.krasrc, optimizeModules = exports.debugPiralDefaults.optimizeModules, feed, _ = {}, hooks = {}, bundlerName, } = options;
    (0, common_1.ensure)('baseDir', baseDir, 'string');
    (0, common_1.ensure)('publicUrl', originalPublicUrl, 'string');
    (0, common_1.ensure)('port', originalPort, ['number', 'undefined']);
    (0, common_1.ensure)('entry', entry, 'string');
    (0, common_1.ensure)('_', _, 'object');
    (0, common_1.ensure)('hooks', hooks, 'object');
    (0, common_1.ensure)('target', target, 'string');
    const publicUrl = (0, common_1.normalizePublicUrl)(originalPublicUrl);
    const fullBase = (0, path_1.resolve)(process.cwd(), baseDir);
    const network = {
        port: originalPort,
        type: strictPort ? 'wanted' : 'proposed',
    };
    (0, common_1.setLogLevel)(logLevel);
    await hooks.onBegin?.({ options, fullBase });
    (0, common_1.progress)('Reading configuration ...');
    const buildRef = await (0, common_1.watcherTask)(async (watcherContext) => {
        const entryFiles = await (0, common_1.retrievePiralRoot)(fullBase, entry);
        const { externals, name, root, ignored } = await (0, common_1.retrievePiletsInfo)(entryFiles);
        const piralInstances = [name];
        const dest = (0, common_1.getDestination)(entryFiles, (0, path_1.resolve)(fullBase, target));
        await (0, common_1.checkCliCompatibility)(root);
        (0, common_1.validateSharedDependencies)(externals);
        await hooks.beforeBuild?.({ root, publicUrl, externals, entryFiles, piralInstances });
        const bundler = await (0, bundler_1.callPiralDebug)({
            root,
            piralInstances,
            optimizeModules,
            hmr,
            externals: (0, common_1.flattenExternals)(externals),
            publicUrl,
            entryFiles,
            logLevel,
            ignored,
            ...dest,
            _,
        }, bundlerName);
        watcherContext.watch((0, path_1.join)(root, common_1.packageJson));
        watcherContext.watch((0, path_1.join)(root, common_1.piralJson));
        watcherContext.onClean(() => bundler.stop());
        bundler.ready().then(() => (0, common_1.logDone)(`Ready!`));
        bundler.on((args) => {
            hooks.afterBuild?.({ ...args, root, publicUrl, externals, entryFiles, piralInstances, bundler, ...dest });
        });
        bundler.start();
        return { bundler, entryFiles, root };
    });
    const platform = (0, common_1.configurePlatform)();
    const serverRef = await (0, common_1.watcherTask)(async (watcherContext) => {
        const { bundler, entryFiles, root } = buildRef.data;
        const targetDir = (0, path_1.dirname)(entryFiles);
        const update = await platform.startShell({
            bundler,
            customkrasrc,
            feed,
            fullBase,
            hooks,
            open,
            network,
            publicUrl,
            root,
            targetDir,
            registerEnd(cb) {
                return watcherContext.onClean(cb);
            },
            registerWatcher(file) {
                return watcherContext.watch(file);
            },
        });
        const handleUpdate = () => {
            const { bundler } = buildRef.data;
            update({ bundler });
        };
        buildRef.on(handleUpdate);
        watcherContext.onClean(() => buildRef.off(handleUpdate));
    });
    await Promise.all([buildRef.end, serverRef.end]);
    await hooks.onEnd?.({});
}
//# sourceMappingURL=debug-piral.js.map