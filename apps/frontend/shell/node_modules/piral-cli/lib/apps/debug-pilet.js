"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.debugPiletDefaults = void 0;
exports.debugPilet = debugPilet;
const path_1 = require("path");
const bundler_1 = require("../bundler");
const types_1 = require("../types");
const common_1 = require("../common");
exports.debugPiletDefaults = {
    logLevel: types_1.LogLevels.info,
    target: './dist/index.js',
    entry: './src/index',
    open: common_1.config.openBrowser,
    port: common_1.config.port,
    strictPort: common_1.config.strictPort,
    publicUrl: '/',
    hmr: true,
    krasrc: undefined,
    optimizeModules: false,
    schemaVersion: undefined,
    concurrency: common_1.cpuCount,
};
function byPort(a, b) {
    return a[1] - b[1];
}
function getOrMakeApps({ apps, publicUrl }, logLevel) {
    return Promise.all(apps.map(async ({ emulator, appFile, appPackage, appPort }) => {
        if (!emulator) {
            const piralInstances = [appPackage.name];
            const { externals, root, ignored } = await (0, common_1.retrievePiletsInfo)(appFile);
            const { dir } = await (0, bundler_1.callDebugPiralFromMonoRepo)({
                root,
                optimizeModules: false,
                publicUrl,
                ignored,
                externals: (0, common_1.flattenExternals)(externals),
                piralInstances,
                entryFiles: appFile,
                logLevel,
                _: {},
            });
            return [dir, appPort];
        }
        return [(0, path_1.dirname)(appFile), appPort];
    }));
}
function checkSanity(pilets) {
    for (let i = 1; i < pilets.length; i++) {
        const previous = pilets[i - 1];
        const current = pilets[i];
        const previousInstances = previous.apps;
        const currentInstances = current.apps;
        const previousInstancesNames = previousInstances
            .map((m) => m.appPackage.name)
            .sort()
            .join(', ');
        const currentInstancesNames = currentInstances
            .map((m) => m.appPackage.name)
            .sort()
            .join(', ');
        const previousInstancesVersions = previousInstances.map((m) => m.appPackage.version).join(', ');
        const currentInstancesVersions = currentInstances.map((m) => m.appPackage.version).join(', ');
        if (previousInstancesNames !== currentInstancesNames) {
            return (0, common_1.log)('piletMultiDebugAppShellDifferent_0301', previousInstancesNames, currentInstancesNames);
        }
        else if (previousInstancesVersions !== currentInstancesVersions) {
            return (0, common_1.log)('piletMultiDebugAppShellVersions_0302', previousInstancesVersions, currentInstancesVersions);
        }
        else if (previous.externals.length !== current.externals.length) {
            return (0, common_1.log)('piletMultiDebugExternalsDifferent_0303', previous.externals, current.externals);
        }
        else if (previous.externals.some((m) => !current.externals.includes(m))) {
            return (0, common_1.log)('piletMultiDebugExternalsDifferent_0303', previous.externals, current.externals);
        }
    }
}
async function debugPilet(baseDir = process.cwd(), options = {}) {
    const { entry = exports.debugPiletDefaults.entry, target = exports.debugPiletDefaults.target, open = exports.debugPiletDefaults.open, hmr = exports.debugPiletDefaults.hmr, port: originalPort = exports.debugPiletDefaults.port, strictPort = exports.debugPiletDefaults.strictPort, publicUrl: originalPublicUrl = exports.debugPiletDefaults.publicUrl, logLevel = exports.debugPiletDefaults.logLevel, concurrency = exports.debugPiletDefaults.concurrency, krasrc: customkrasrc = exports.debugPiletDefaults.krasrc, optimizeModules = exports.debugPiletDefaults.optimizeModules, schemaVersion: originalSchemaVersion = exports.debugPiletDefaults.schemaVersion, _ = {}, hooks = {}, bundlerName, app, appInstanceDir, feed, } = options;
    (0, common_1.ensure)('baseDir', baseDir, 'string');
    (0, common_1.ensure)('_', _, 'object');
    (0, common_1.ensure)('hooks', hooks, 'object');
    (0, common_1.ensure)('target', target, 'string');
    (0, common_1.ensure)('publicUrl', originalPublicUrl, 'string');
    (0, common_1.ensure)('port', originalPort, ['number', 'undefined']);
    const publicUrl = (0, common_1.normalizePublicUrl)(originalPublicUrl);
    const fullBase = (0, path_1.resolve)(process.cwd(), baseDir);
    const networks = [];
    (0, common_1.setLogLevel)(logLevel);
    await hooks.onBegin?.({ options, fullBase });
    (0, common_1.progress)('Reading configuration ...');
    const entryList = Array.isArray(entry) ? entry : [entry];
    const multi = entryList.length > 1 || entryList[0].indexOf('*') !== -1;
    (0, common_1.log)('generalDebug_0003', `Looking for (${multi ? 'multi' : 'single'}) "${entryList.join('", "')}" in "${fullBase}".`);
    const allEntries = await (0, common_1.matchAnyPilet)(fullBase, entryList);
    (0, common_1.log)('generalDebug_0003', `Found the following entries: ${allEntries.join(', ')}`);
    if (allEntries.length === 0) {
        (0, common_1.fail)('entryFileMissing_0077');
    }
    const maxListeners = Math.max(2 + allEntries.length * 2, 16);
    process.stderr?.setMaxListeners(maxListeners);
    process.stdout?.setMaxListeners(maxListeners);
    process.stdin?.setMaxListeners(maxListeners);
    const buildRef = await (0, common_1.watcherTask)(async (watcherContext) => {
        const pilets = await (0, common_1.concurrentWorkers)(allEntries, concurrency, async (entryModule) => {
            const targetDir = (0, path_1.dirname)(entryModule);
            const { peerDependencies, peerModules, root, apps, ignored, importmap, schema } = await (0, common_1.retrievePiletData)(targetDir, app);
            const schemaVersion = originalSchemaVersion || schema || common_1.config.schemaVersion || common_1.defaultSchemaVersion;
            const piralInstances = apps.map((m) => m.appPackage.name);
            const externals = (0, common_1.combinePiletExternals)(piralInstances, peerDependencies, peerModules, importmap);
            const mocks = (0, path_1.join)(targetDir, 'mocks');
            const dest = (0, path_1.resolve)(root, target);
            const outDir = (0, path_1.dirname)(dest);
            const outFile = (0, path_1.basename)(dest);
            const mocksExists = await (0, common_1.checkExistingDirectory)(mocks);
            (0, common_1.validateSharedDependencies)(importmap);
            await hooks.beforeBuild?.({ root, publicUrl, importmap, entryModule, schemaVersion });
            const bundler = await (0, bundler_1.callPiletDebug)({
                root,
                piralInstances,
                optimizeModules,
                hmr,
                externals,
                targetDir,
                importmap,
                outFile,
                outDir,
                entryModule: `./${(0, path_1.relative)(root, entryModule)}`,
                logLevel,
                version: schemaVersion,
                ignored,
                _,
            }, bundlerName);
            watcherContext.watch((0, path_1.join)(root, common_1.packageJson));
            watcherContext.watch((0, path_1.join)(root, common_1.piletJson));
            watcherContext.onClean(() => bundler.stop());
            bundler.on((args) => {
                hooks.afterBuild?.({
                    ...args,
                    root,
                    publicUrl,
                    importmap,
                    entryModule,
                    schemaVersion,
                    bundler,
                    outFile,
                    outDir,
                });
            });
            return {
                apps,
                publicUrl,
                externals,
                bundler,
                mocks: mocksExists ? mocks : undefined,
                root,
            };
        });
        // sanity check see #250
        checkSanity(pilets);
        Promise.all(pilets.map((p) => p.bundler.ready())).then(() => (0, common_1.logDone)(`Ready!`));
        return { pilets };
    });
    const watcherRef = await (0, common_1.watcherTask)(async (watcherContext) => {
        const { pilets } = buildRef.data;
        await hooks.beforeApp?.({ appInstanceDir, pilets });
        const appInstances = appInstanceDir
            ? [[appInstanceDir, 0]]
            : await getOrMakeApps(pilets[0], logLevel);
        pilets.forEach((p) => p.bundler.start());
        if (appInstances.length === 0) {
            appInstances.push([undefined, originalPort]);
        }
        await Promise.all(appInstances.sort(byPort).map(async ([appDir, appPort], i) => {
            const platform = (0, common_1.configurePlatform)();
            if (networks.length === i) {
                networks.push({
                    port: appPort || originalPort + i,
                    type: strictPort ? 'wanted' : 'proposed',
                });
            }
            const update = await platform.startModule({
                appDir,
                pilets,
                customkrasrc,
                feed,
                fullBase,
                hooks,
                open,
                network: networks[i],
                publicUrl,
                maxListeners,
                registerEnd(cb) {
                    return watcherContext.onClean(cb);
                },
                registerWatcher(file) {
                    return watcherContext.watch(file);
                },
            });
            const handleUpdate = () => {
                const { pilets } = buildRef.data;
                pilets.forEach((p) => p.bundler.start());
                update({ pilets });
            };
            buildRef.on(handleUpdate);
            watcherContext.onClean(() => buildRef.off(handleUpdate));
        }));
        await hooks.afterApp?.({ appInstanceDir, pilets });
    });
    await Promise.all([watcherRef.end]);
    await hooks.onEnd?.({});
}
//# sourceMappingURL=debug-pilet.js.map