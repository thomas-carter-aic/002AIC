"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runQuestionnaireFor = runQuestionnaireFor;
exports.runQuestionnaire = runQuestionnaire;
const external_1 = require("./external");
const commands_1 = require("./commands");
function getCommandData(retrieve) {
    const instructions = [];
    const fn = {
        alias(name, altName) {
            return this.swap(name, (flag) => ({
                ...flag,
                alias: [...flag.alias, altName],
            }));
        },
        positional(name, info) {
            instructions.push({
                ...info,
                alias: [],
                name,
            });
            return this;
        },
        swap(name, swapper) {
            const [flag] = instructions.filter((m) => m.name === name);
            const newFlag = swapper(flag || { name, alias: [] });
            if (!flag) {
                instructions.push(newFlag);
            }
            else {
                Object.assign(flag, newFlag);
            }
            return this;
        },
        option(name) {
            return this.swap(name, (flag) => ({
                ...flag,
                value: {},
                type: 'object',
            }));
        },
        choices(name, choices) {
            return this.swap(name, (flag) => ({
                ...flag,
                type: 'string',
                values: choices,
            }));
        },
        string(name) {
            return this.swap(name, (flag) => ({
                ...flag,
                type: 'string',
            }));
        },
        boolean(name) {
            return this.swap(name, (flag) => ({
                ...flag,
                type: 'boolean',
            }));
        },
        describe(name, value) {
            return this.swap(name, (flag) => ({
                ...flag,
                describe: value,
            }));
        },
        default(name, value) {
            return this.swap(name, (flag) => ({
                ...flag,
                default: value,
            }));
        },
        number(name) {
            return this.swap(name, (flag) => ({
                ...flag,
                type: 'number',
            }));
        },
        demandOption(name) {
            return this.swap(name, (flag) => ({
                ...flag,
                required: true,
            }));
        },
    };
    if (typeof retrieve === 'function') {
        retrieve(fn);
    }
    return instructions;
}
function getValue(type, value) {
    switch (type) {
        case 'boolean':
            return !!value;
        case 'number':
            return +value;
        case 'string':
            return value;
        case 'object':
            return value;
    }
}
function getType(flag) {
    switch (flag.type) {
        case 'string':
            if (flag.values) {
                return 'list';
            }
            return 'input';
        case 'number':
            return 'input';
        case 'boolean':
            return 'confirm';
    }
}
function runQuestionnaireFor(command, args, ignoredInstructions = ['base', 'log-level'], extraInstructions = []) {
    const acceptAll = args.y === true || args.defaults === true;
    const instructions = [...getCommandData(command.flags), ...extraInstructions];
    const ignored = Array.isArray(ignoredInstructions) ? ignoredInstructions : Object.keys(ignoredInstructions);
    const questions = instructions
        .filter((instruction) => !ignored.includes(instruction.name))
        .filter((instruction) => !acceptAll || (instruction.default === undefined && instruction.required))
        .filter((instruction) => [...instruction.alias, instruction.name].every((m) => args[m] === undefined))
        .filter((instruction) => instruction.type !== 'object')
        .map((instruction) => ({
        name: instruction.name,
        default: instruction.values ? instruction.values.indexOf(instruction.default) : instruction.default,
        message: instruction.describe,
        type: getType(instruction),
        choices: instruction.values,
        validate: instruction.validate || (instruction.type === 'number' ? (input) => !isNaN(+input) : () => true),
        filter: instruction.filter,
        when: instruction.when,
    }));
    return external_1.inquirer.prompt(questions).then((answers) => {
        const parameters = {};
        for (const instruction of instructions) {
            if (!instruction.ignore && (!instruction.when || instruction.when(answers))) {
                const name = instruction.name;
                const value = answers[name] ??
                    ignoredInstructions[name] ??
                    [...instruction.alias, instruction.name].map((m) => args[m]).find((v) => v !== undefined);
                const convert = instruction.convert || ((value) => value);
                const result = convert(value !== undefined ? getValue(instruction.type, value) : instruction.default);
                if (typeof result === 'object' && typeof parameters[name] === 'object') {
                    Object.assign(parameters[name], result);
                }
                else {
                    parameters[name] = result;
                }
            }
        }
        return command.run(parameters);
    });
}
function runQuestionnaire(commandName, ignoredInstructions = ['base', 'log-level'], extraInstructions = []) {
    const { argv } = require('yargs');
    const [command] = commands_1.commands.all.filter((m) => m.name === commandName);
    return runQuestionnaireFor(command, argv, ignoredInstructions, extraInstructions);
}
//# sourceMappingURL=questionnaire.js.map