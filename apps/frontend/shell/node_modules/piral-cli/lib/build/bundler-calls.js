"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.callDynamic = callDynamic;
exports.callStatic = callStatic;
const path_1 = require("path");
const child_process_1 = require("child_process");
function getPath(name) {
    return (0, path_1.resolve)(__dirname, '..', '..', 'lib', 'build', `run-${name}.js`);
}
function createBundler(cwd, ps, args) {
    let promise = Promise.resolve();
    let started = false;
    const listeners = [];
    const bundle = {
        dir: cwd,
        hash: '',
        name: '',
    };
    const setPending = () => {
        promise = new Promise((done) => {
            const f = () => {
                done();
                bundler.off(f);
            };
            bundler.on(f);
        });
    };
    const bundler = {
        bundle,
        start() {
            if (!started) {
                started = true;
                ps.send({
                    type: 'bundle',
                    ...args,
                });
            }
        },
        stop() {
            return new Promise((resolve) => {
                ps.on('exit', resolve);
                ps.kill();
            });
        },
        on(cb) {
            listeners.push(cb);
        },
        off(cb) {
            listeners.splice(listeners.indexOf(cb), 1);
        },
        emit(args) {
            [...listeners].forEach((cb) => cb(args));
        },
        ready() {
            return promise;
        },
        setPending,
    };
    setPending();
    return bundler;
}
function callDynamic(name, path, args, exec) {
    const cwd = args.root;
    return new Promise((resolve, reject) => {
        const ps = (0, child_process_1.fork)(getPath(name), [], { cwd, stdio: 'pipe', env: process.env, execPath: exec });
        const bundler = createBundler(cwd, ps, args);
        const setup = {
            type: 'init',
            path,
        };
        const start = () => {
            ps.send({
                type: 'start',
                ...args,
            });
        };
        ps.stderr && process.stderr && ps.stderr.pipe(process.stderr, { end: false });
        ps.stdout && process.stdout && ps.stdout.pipe(process.stdout, { end: false });
        ps.stdin && process.stdin && ps.stdin.pipe(process.stdin, { end: false });
        ps.on('message', (msg) => {
            switch (msg.type) {
                case 'pending':
                    bundler.setPending();
                    break;
                case 'update':
                    bundler.bundle.hash = msg.outHash;
                    bundler.bundle.name = msg.outName;
                    bundler.emit(msg.args);
                    break;
                case 'done':
                    bundler.bundle.dir = msg.outDir;
                    return resolve(bundler);
                case 'fail':
                    return reject(msg.error);
            }
        });
        ps.send(setup, start);
    });
}
function callStatic(name, path, args, exec) {
    const cwd = args.root;
    return new Promise((resolve, reject) => {
        const ps = (0, child_process_1.fork)(getPath(name), [], { cwd, stdio: 'pipe', env: process.env, execPath: exec });
        const bundler = createBundler(cwd, ps, args);
        const setup = {
            type: 'init',
            path,
        };
        const start = () => {
            ps.send({
                type: 'start',
                ...args,
            });
        };
        ps.stderr && process.stderr && ps.stderr.pipe(process.stderr, { end: false });
        ps.stdout && process.stdout && ps.stdout.pipe(process.stdout, { end: false });
        ps.stdin && process.stdin && ps.stdin.pipe(process.stdin, { end: false });
        ps.on('message', (msg) => {
            switch (msg.type) {
                case 'done':
                    bundler.bundle.dir = msg.outDir;
                    bundler.bundle.name = msg.outFile;
                    return resolve(bundler);
                case 'fail':
                    return reject(msg.error);
            }
        });
        ps.send(setup, start);
    });
}
//# sourceMappingURL=bundler-calls.js.map