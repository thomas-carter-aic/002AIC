"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const promises_1 = require("fs/promises");
const external_1 = require("../external");
/**
 * The maximum amount of retries when sending a response
 */
const maxRetrySendResponse = 4;
async function isNoFile(target) {
    try {
        const info = await (0, promises_1.stat)(target);
        return !info.isFile();
    }
    catch {
        return true;
    }
}
class PiralInjector {
    constructor(options, _config, core) {
        this.cbs = {};
        this.forwardBundlerEvent = (args) => {
            for (const id of Object.keys(this.cbs)) {
                this.cbs[id](JSON.stringify(args));
            }
        };
        this.config = options;
        if (this.config.active) {
            const api = '/$events';
            core.on('user-connected', (e) => {
                if (e.target === '*' && e.url === api.substring(1)) {
                    this.cbs[e.id] = (msg) => e.ws.send(msg);
                }
            });
            core.on('user-disconnected', (e) => {
                delete this.cbs[e.id];
            });
            this.setupBundler();
        }
    }
    setupBundler() {
        this.config.bundler.on(this.forwardBundlerEvent);
    }
    teardownBundler() {
        this.config.bundler.off(this.forwardBundlerEvent);
    }
    get active() {
        return this.config.active;
    }
    set active(value) {
        this.config.active = value;
    }
    get name() {
        return 'piral-injector';
    }
    getOptions() {
        return {};
    }
    setOptions(options) {
        if ('bundler' in options) {
            this.teardownBundler();
            this.config.bundler = options.bundler;
            this.setupBundler();
        }
    }
    sendContent(content, type, url) {
        const { headers } = this.config;
        return {
            injector: { name: this.name },
            headers: {
                ...headers,
                'content-type': type,
                'cache-control': 'no-cache, no-store, must-revalidate',
                pragma: 'no-cache',
                expires: '0',
            },
            status: { code: 200 },
            url,
            content,
        };
    }
    async sendIndexFile(target, url) {
        const indexHtml = await (0, promises_1.readFile)(target, 'utf8');
        const { feed } = this.config;
        if (feed) {
            // mechanism to inject server side debug piletApi config into piral emulator
            const windowInjectionScript = `window['dbg:pilet-api'] = '${feed}';`;
            const findStr = `<script`;
            const replaceStr = `<script>/* Pilet Debugging Emulator Config Injection */${windowInjectionScript}</script><script`;
            const content = indexHtml.replace(`${findStr}`, `${replaceStr}`);
            return this.sendContent(content, external_1.mime.getType(target), url);
        }
        return this.sendContent(indexHtml, external_1.mime.getType(target), url);
    }
    async sendResponse(path, target, dir, url, recursionDepth = 0) {
        if (recursionDepth > maxRetrySendResponse) {
            return undefined;
        }
        const { bundler } = this.config;
        const newTarget = (0, path_1.join)(bundler.bundle.dir, bundler.bundle.name);
        if (!path || (await isNoFile(target))) {
            return await this.sendResponse(bundler.bundle.name, newTarget, dir, url, recursionDepth + 1);
        }
        else if (target === newTarget) {
            return await this.sendIndexFile(target, url);
        }
        else {
            const type = external_1.mime.getType(target) ?? 'application/octet-stream';
            const content = await (0, promises_1.readFile)(target);
            return this.sendContent(content, type, url);
        }
    }
    async handle(req) {
        if (!req.target) {
            const { bundler, publicUrl } = this.config;
            if (req.url.startsWith(publicUrl) || `${req.url}/` === publicUrl) {
                const pathLength = publicUrl.length || 1;
                const path = req.url.substring(pathLength);
                const dir = bundler.bundle.dir;
                const target = (0, path_1.join)(dir, path.split('?').shift());
                await bundler.ready();
                return await this.sendResponse(path, target, dir, req.url);
            }
        }
    }
}
exports.default = PiralInjector;
//# sourceMappingURL=piral-injector.js.map