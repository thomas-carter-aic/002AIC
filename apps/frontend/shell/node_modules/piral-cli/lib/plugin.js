"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadPlugins = loadPlugins;
const fs_1 = require("fs");
const path_1 = require("path");
const common_1 = require("./common");
const inject_1 = require("./inject");
var rx = new RegExp(`/\\.pnpm/${common_1.cliName}@${common_1.cliVersion}(_[a-z0-9@_\\-\\.]+)?/node_modules/${common_1.cliName}/`);
function getContainerDir() {
    const currentDir = __dirname.split(path_1.sep).join(path_1.posix.sep);
    if (!rx.test(currentDir)) {
        return (0, path_1.resolve)(__dirname, '..', '..');
    }
    return undefined;
}
async function getLocalPackageDir() {
    const proposedDirs = [
        getContainerDir(),
        (0, path_1.resolve)(process.cwd(), 'node_modules'),
        (0, path_1.resolve)(process.cwd(), '..', 'node_modules'),
        (0, path_1.resolve)(process.cwd(), '..', '..', 'node_modules'),
        (0, path_1.resolve)(process.cwd(), '..', '..', '..', 'node_modules'),
    ];
    // Right now we always take the first one, but in the future this may be different
    // once we come up with more / better criteria to identify if its a good/valid
    // plugin root directory
    for (const dir of proposedDirs.filter(Boolean)) {
        (0, common_1.log)('generalDebug_0003', `Checking for potential plugin directory "${dir}" ...`);
        if (await isValidModulesDirectory(dir)) {
            return dir;
        }
    }
    return undefined;
}
function isValidModulesDirectory(dir) {
    return isDirectory((0, path_1.resolve)(dir, 'piral-cli'));
}
function isDirectory(dir) {
    return new Promise((resolve) => {
        (0, fs_1.stat)(dir, (err, stats) => {
            if (err) {
                // this happens, e.g., when the path does not exist
                // see: https://github.com/smapiot/piral/issues/624
                resolve(false);
            }
            else {
                resolve(stats.isDirectory());
            }
        });
    });
}
function listDirectory(rootDir) {
    return new Promise((resolve) => {
        (0, fs_1.readdir)(rootDir, (_, files) => resolve(files || []));
    });
}
async function isPluginDirectory(dir) {
    try {
        return await isDirectory(dir);
    }
    catch (err) {
        (0, common_1.log)('generalDebug_0003', `Could not load the plugin at "${dir}": ${err}`);
        return false;
    }
}
function isPlugin(name) {
    const prefix = 'piral-cli-';
    return name.startsWith(prefix) && name.length > prefix.length;
}
function isScope(name) {
    const prefix = '@';
    return name.startsWith(prefix) && name.length > prefix.length;
}
async function fillPlugins(candidates, plugins) {
    await Promise.all(candidates.map(async (path) => {
        if (await isPluginDirectory(path)) {
            plugins.push(path);
        }
    }));
}
async function getAllPlugins(rootDir) {
    if (rootDir) {
        (0, common_1.log)('generalDebug_0003', `Getting plugins from dir "${rootDir}" ...`);
        const pluginPaths = await listDirectory(rootDir);
        const plugins = [];
        const nested = pluginPaths.filter(isScope).map((m) => (0, path_1.join)(rootDir, m));
        await Promise.all([
            fillPlugins(pluginPaths.filter(isPlugin).map((m) => (0, path_1.join)(rootDir, m)), plugins),
            ...nested.map(async (path) => {
                const files = await listDirectory(path);
                await fillPlugins(files.filter(isPlugin).map((m) => (0, path_1.join)(path, m)), plugins);
            }),
        ]);
        return plugins;
    }
    else {
        (0, common_1.log)('generalDebug_0003', `Skipping plugins from dir "${rootDir}" ...`);
        return [];
    }
}
async function loadPlugins() {
    const localDir = await getLocalPackageDir();
    const allPlugins = await getAllPlugins(localDir);
    for (const pluginPath of allPlugins) {
        (0, inject_1.inject)(pluginPath);
    }
}
//# sourceMappingURL=plugin.js.map