"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPiralScaffoldData = getPiralScaffoldData;
exports.scaffoldPiralSourceFiles = scaffoldPiralSourceFiles;
exports.getPiletScaffoldData = getPiletScaffoldData;
exports.scaffoldPiletSourceFiles = scaffoldPiletSourceFiles;
const path_1 = require("path");
const npm_1 = require("./npm");
const io_1 = require("./io");
const info_1 = require("./info");
const log_1 = require("./log");
function getTemplatePackage(templatePackageName) {
    const idx = templatePackageName.indexOf('@', 1);
    const normalizedName = idx > 0 && !(0, path_1.isAbsolute)(templatePackageName) ? templatePackageName.substring(0, idx) : templatePackageName;
    try {
        return require(normalizedName);
    }
    catch {
        (0, log_1.fail)('generalError_0002', `Could not find the given template "${templatePackageName}". Package "${normalizedName}" could not be resolved.`);
    }
}
async function getTemplateFiles(templatePackageName, registry, root, data, forceOverwrite) {
    // debug in monorepo such as "../templates/pilet-template-react/lib/index.js"
    if (templatePackageName.startsWith('.')) {
        templatePackageName = (0, path_1.resolve)(process.cwd(), templatePackageName);
    }
    else {
        if (templatePackageName.indexOf('@', 1) === -1) {
            templatePackageName = `${templatePackageName}@latest`;
        }
        await (0, npm_1.installNpmPackageFromOptionalRegistry)(templatePackageName, __dirname, registry);
    }
    const templateRunner = getTemplatePackage(templatePackageName);
    const logLevel = (0, log_1.getLogLevel)();
    const details = {
        forceOverwrite,
        cliVersion: info_1.cliVersion,
        isWindows: info_1.isWindows,
        logLevel,
    };
    if (typeof templateRunner === 'function') {
        return await templateRunner(root, data, details);
    }
    else if ('default' in templateRunner && typeof templateRunner.default === 'function') {
        return await templateRunner.default(root, data, details);
    }
    else {
        (0, log_1.fail)('generalError_0002', `The provided template package "${templatePackageName}" does not export a template factory function.`);
    }
}
function writeFiles(root, files, forceOverwrite) {
    const rootPackage = (0, path_1.resolve)(root, 'package.json');
    return Promise.all(files
        .filter((file) => {
        if (typeof file.path !== 'string') {
            (0, log_1.log)('generalWarning_0001', `The supplied file path ("${file.path}") is not a string. Skipping.`);
            return false;
        }
        else if (typeof file.content === 'undefined') {
            (0, log_1.log)('generalWarning_0001', `The file "${file.path}" did not specify any content. Skipping.`);
            return false;
        }
        return true;
    })
        .map((file) => {
        const target = (0, path_1.resolve)(root, file.path);
        const name = (0, path_1.basename)(target);
        const dir = (0, path_1.dirname)(target);
        if (target !== rootPackage) {
            return (0, io_1.createFileIfNotExists)(dir, name, file.content, forceOverwrite);
        }
        else {
            return (0, io_1.updateExistingJson)(dir, name, JSON.parse(file.content.toString('utf8')));
        }
    }));
}
function getTemplatePackageName(type, template) {
    if (template.indexOf('/') === -1 && !template.startsWith('.')) {
        return `@smapiot/${type}-template-${template}`;
    }
    return template;
}
function getPiralScaffoldData(language, root, app, packageName, variables) {
    const src = (0, path_1.dirname)((0, path_1.join)(root, app));
    return {
        ...variables,
        root,
        src,
        language,
        packageName,
        reactVersion: parseInt(variables.reactVersion) || 18,
        reactRouterVersion: parseInt(variables.reactRouterVersion) || 5,
    };
}
async function scaffoldPiralSourceFiles(template, registry, data, forceOverwrite) {
    const { src, root } = data;
    const templatePackageName = getTemplatePackageName('piral', template);
    await (0, io_1.createDirectory)(src);
    const files = await getTemplateFiles(templatePackageName, registry, root, data, forceOverwrite);
    await writeFiles(root, files, forceOverwrite);
}
function getPiletScaffoldData(language, root, sourceName, variables) {
    const src = (0, path_1.join)(root, 'src');
    return {
        ...variables,
        root,
        src,
        language,
        sourceName,
    };
}
async function scaffoldPiletSourceFiles(template, registry, data, forceOverwrite) {
    const { src, root } = data;
    const templatePackageName = getTemplatePackageName('pilet', template);
    await (0, io_1.createDirectory)(src);
    const files = await getTemplateFiles(templatePackageName, registry, root, data, forceOverwrite);
    await writeFiles(root, files, forceOverwrite);
}
//# sourceMappingURL=scaffold.js.map