"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createEmulatorSources = createEmulatorSources;
exports.createEmulatorWebsite = createEmulatorWebsite;
exports.packageEmulator = packageEmulator;
const path_1 = require("path");
const package_1 = require("./package");
const template_1 = require("./template");
const constants_1 = require("./constants");
const info_1 = require("./info");
const npm_1 = require("./npm");
const declaration_1 = require("./declaration");
const enums_1 = require("./enums");
const archive_1 = require("./archive");
const io_1 = require("./io");
const io_2 = require("./io");
function makeFilesMap(files = []) {
    return files
        .filter((file) => file && (typeof file === 'string' || typeof file === 'object'))
        .map((file) => (typeof file === 'string' ? { from: file, to: file } : file))
        .filter((file) => typeof file.to === 'string' && typeof file.from === 'string')
        .map((file) => ({
        ...file,
        to: file.to.replace(/\\/g, '/'),
        from: (0, path_1.join)('files', file.to).replace(/\\/g, '/'),
    }));
}
async function makeExternals(sourceDir, piralPkg, externals) {
    const externalPackages = await Promise.all(externals
        .filter((ext) => ext.type === 'local' && (0, package_1.isValidDependency)(ext.name))
        .map(async (external) => ({
        name: external.name,
        version: await (0, package_1.findDependencyVersion)(piralPkg, sourceDir, external),
        optional: external.isAsync,
    })));
    const externalDependencies = externalPackages.reduce((deps, dep) => {
        if (!dep.optional) {
            deps[dep.name] = dep.version;
        }
        return deps;
    }, {});
    const importmapEntries = externalPackages.reduce((deps, dep) => {
        deps[dep.name] = dep.name;
        return deps;
    }, {});
    const optionalDependencies = externalPackages.reduce((deps, dep) => {
        if (dep.optional) {
            deps[dep.name] = dep.name;
        }
        return deps;
    }, {});
    return [externalDependencies, importmapEntries, optionalDependencies];
}
async function createScaffoldingTarballs(sourceDir, targetDir, files = []) {
    const filesDir = (0, path_1.resolve)(targetDir, constants_1.filesTar);
    const filesOnceDir = (0, path_1.resolve)(targetDir, constants_1.filesOnceTar);
    await Promise.all([(0, io_1.createDirectory)(filesDir), (0, io_1.createDirectory)(filesOnceDir)]);
    // for scaffolding we need to keep the files also available in the new package
    await (0, package_1.copyScaffoldingFiles)(sourceDir, filesDir, files.filter((m) => typeof m === 'string' || !m.once));
    // also to avoid information loss we should store the once-only files separately
    await (0, package_1.copyScaffoldingFiles)(sourceDir, filesOnceDir, files.filter((m) => typeof m !== 'string' && m.once));
    // since things like .gitignore are not properly treated by npm we pack the files (for standard and once only)
    await Promise.all([
        (0, archive_1.createTarball)(filesDir, targetDir, `${constants_1.filesTar}.tar`),
        (0, archive_1.createTarball)(filesOnceDir, targetDir, `${constants_1.filesOnceTar}.tar`),
    ]);
    // ... and remove the directory
    await Promise.all([(0, io_1.removeDirectory)(filesDir), (0, io_1.removeDirectory)(filesOnceDir)]);
}
async function createEmulatorSources(sourceDir, externals, targetDir, targetFile, logLevel) {
    const piralPkg = await (0, io_2.readJson)(sourceDir, constants_1.packageJson);
    const piralJsonPkg = await (0, io_2.readJson)(sourceDir, constants_1.piralJson);
    const pilets = {
        ...piralPkg.pilets,
        ...piralJsonPkg.pilets,
    };
    const allDeps = {
        ...piralPkg.devDependencies,
        ...piralPkg.dependencies,
    };
    const rootDir = (0, path_1.resolve)(targetDir, '..');
    const appDir = (0, path_1.relative)(rootDir, targetDir);
    const [externalDependencies, importmapEntries, optionalDependencies] = await makeExternals(sourceDir, piralPkg, externals);
    // do not modify an existing JSON
    await (0, io_2.createFileIfNotExists)(rootDir, constants_1.packageJson, '{}');
    // patch the JSON relevant for the project
    await (0, io_2.updateExistingJson)(rootDir, constants_1.packageJson, {
        name: piralPkg.name,
        description: piralPkg.description,
        version: piralPkg.version,
        license: piralPkg.license,
        homepage: piralPkg.homepage,
        keywords: piralPkg.keywords,
        importmap: {
            imports: importmapEntries,
        },
        pilets: {
            ...pilets,
            files: makeFilesMap(pilets.files),
        },
        piralCLI: {
            version: info_1.cliVersion,
            generated: true,
        },
        main: `./${path_1.posix.join(appDir, 'index.js')}`,
        typings: `./${path_1.posix.join(appDir, 'index.d.ts')}`,
        app: `./${path_1.posix.join(appDir, 'index.html')}`,
        peerDependencies: {},
        optionalDependencies,
        devDependencies: {
            ...allDeps,
            ...externalDependencies,
        },
        sharedDependencies: (0, package_1.flattenExternals)(externals, true),
        repository: piralPkg.repository,
        bugs: piralPkg.bugs,
        author: piralPkg.author,
        contributors: piralPkg.contributors,
        engines: piralPkg.engines,
        cpu: piralPkg.cpu,
        publishConfig: piralPkg.publishConfig,
    });
    // we just want to make sure that "files" mentioned in the original package.json are respected in the package
    await (0, package_1.copyScaffoldingFiles)(sourceDir, rootDir, piralPkg.files ?? []);
    // actually including this one hints that the app shell should have been included - which is forbidden
    await (0, template_1.createPiralStubIndexIfNotExists)(targetDir, 'index.js', enums_1.ForceOverwrite.yes, {
        name: piralPkg.name,
        outFile: (0, path_1.basename)(targetFile),
    });
    // generate the associated index.d.ts
    await (0, declaration_1.createPiralDeclaration)(sourceDir, piralPkg.app ?? `./src/index.html`, targetDir, enums_1.ForceOverwrite.yes, logLevel);
    // generate the files.tar and files_once.tar files
    await createScaffoldingTarballs(sourceDir, rootDir, pilets.files);
    return rootDir;
}
async function createEmulatorWebsite(sourceDir, externals, targetDir, targetFile, logLevel) {
    const piralPkg = await (0, io_2.readJson)(sourceDir, constants_1.packageJson);
    const piralJsonPkg = await (0, io_2.readJson)(sourceDir, constants_1.piralJson);
    const pilets = {
        ...piralPkg.pilets,
        ...piralJsonPkg.pilets,
    };
    const allDeps = {
        ...piralPkg.devDependencies,
        ...piralPkg.dependencies,
    };
    const [externalDependencies, importmapEntries, optionalDependencies] = await makeExternals(sourceDir, piralPkg, externals);
    const allFiles = await (0, io_1.matchFiles)(targetDir, '*');
    const data = {
        name: piralPkg.name,
        description: piralPkg.description,
        version: piralPkg.version,
        timestamp: new Date().toISOString(),
        scaffolding: {
            pilets: {
                ...pilets,
                files: makeFilesMap(pilets.files),
            },
            cli: info_1.cliVersion,
        },
        files: {
            typings: 'index.d.ts',
            main: (0, path_1.basename)(targetFile),
            app: 'index.html',
            always: `${constants_1.filesTar}.tar`,
            once: `${constants_1.filesOnceTar}.tar`,
            assets: allFiles.map((file) => (0, path_1.relative)(targetDir, file)),
        },
        importmap: {
            imports: importmapEntries,
        },
        dependencies: {
            optional: optionalDependencies,
            included: {
                ...allDeps,
                ...externalDependencies,
            },
        },
    };
    await (0, io_2.writeJson)(targetDir, constants_1.emulatorJson, data, true);
    // generate the associated index.d.ts
    await (0, declaration_1.createPiralDeclaration)(sourceDir, piralPkg.app ?? `./src/index.html`, targetDir, enums_1.ForceOverwrite.yes, logLevel);
    // generate the files.tar and files_once.tar files
    await createScaffoldingTarballs(sourceDir, targetDir, pilets.files);
    return targetDir;
}
async function packageEmulator(rootDir) {
    // finally package everything up
    await (0, npm_1.createNpmPackage)(rootDir);
    // get all files
    const names = await (0, io_1.getFileNames)(rootDir);
    // cleanup
    await Promise.all(names
        .filter((name) => !name.endsWith('.tgz'))
        .map((name) => (0, path_1.resolve)(rootDir, name))
        .map((file) => (0, io_1.removeAny)(file)));
}
//# sourceMappingURL=emulator.js.map