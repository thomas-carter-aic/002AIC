"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPiletDeclaration = createPiletDeclaration;
exports.createPiralDeclaration = createPiralDeclaration;
const dets_1 = require("dets");
const path_1 = require("path");
const log_1 = require("./log");
const package_1 = require("./package");
const constants_1 = require("./constants");
const io_1 = require("./io");
const external_1 = require("../external");
const piletApiName = 'PiletApi';
function findPiralBaseRoot(root, framework) {
    const piralJson = `${framework}/package.json`;
    if (piralJson !== constants_1.piralBaseRoot) {
        try {
            const packageJsonPath = (0, external_1.getModulePath)(root, piralJson);
            return (0, path_1.dirname)(packageJsonPath);
        }
        catch { }
    }
    return root;
}
async function findPiralInstanceApi(root, piralInstance) {
    if (piralInstance) {
        const path = require.resolve(`${piralInstance}/${constants_1.packageJson}`, {
            paths: [(0, path_1.join)(root, 'node_modules')],
        });
        const appRoot = (0, path_1.dirname)(path);
        const data = await (0, io_1.readJson)(appRoot, constants_1.packageJson);
        const subpath = data.types || data.typings;
        if (subpath) {
            return [
                {
                    file: (0, path_1.resolve)(appRoot, subpath),
                    name: piletApiName,
                },
            ];
        }
    }
    return [];
}
function findPiralBaseApi(root, framework) {
    // for some package managers, e.g., pnpm we need to first go into
    // some specifics before being able to retrieve "piral-base"
    const baseRoot = findPiralBaseRoot(root, framework);
    try {
        const packageJsonPath = (0, external_1.getModulePath)(baseRoot, constants_1.piralBaseRoot);
        const projectDir = (0, path_1.dirname)(packageJsonPath);
        const project = require(packageJsonPath);
        // By default support for piral-base < 0.15
        const { piletApiTypings = 'lib/types.d.ts' } = project;
        return [
            {
                file: (0, path_1.resolve)(projectDir, piletApiTypings),
                name: piletApiName,
            },
        ];
    }
    catch (err) {
        (0, log_1.log)('generalError_0002', `Could not find the root API of "piral-base" from "${root}": ${err}`);
        return [];
    }
}
function isString(n) {
    return typeof n === 'string';
}
function findDeclaredTypings(root, shared = []) {
    const types = shared.filter(isString).map((file) => (0, path_1.resolve)(root, file));
    try {
        const { typings, extraTypes } = require((0, path_1.resolve)(root, 'package.json'));
        if (extraTypes) {
            if (isString(extraTypes)) {
                return [(0, path_1.resolve)(root, extraTypes), ...types];
            }
            else if (Array.isArray(extraTypes)) {
                const items = extraTypes.filter(isString).map((file) => (0, path_1.resolve)(root, file));
                return [...items, ...types];
            }
        }
        if (typings) {
            return [(0, path_1.resolve)(root, typings), ...types];
        }
    }
    catch { }
    return types;
}
async function getAllFiles(entryModules) {
    const files = [];
    const pattern = '**/+(*.ts|*.tsx|*.js|*.jsx)';
    const allFiles = await Promise.all(entryModules.map((m) => (0, io_1.matchFiles)((0, path_1.dirname)(m), pattern)));
    for (const found of allFiles) {
        files.push(...found.filter((file) => !files.includes(file)));
    }
    return files;
}
async function getEntryModules(entryFiles) {
    if (!constants_1.entryModuleExtensions.includes((0, path_1.extname)(entryFiles).toLowerCase())) {
        const appFile = await (0, io_1.readText)((0, path_1.dirname)(entryFiles), (0, path_1.basename)(entryFiles));
        const entryModules = await (0, io_1.getEntryFiles)(appFile, (0, path_1.dirname)(entryFiles));
        return entryModules;
    }
    return [entryFiles];
}
function createLogger() {
    return {
        error(message) {
            throw new Error(message);
        },
        info(message) {
            (0, log_1.logInfo)(message);
        },
        verbose(message) {
            (0, log_1.logVerbose)(message);
        },
        warn(message) {
            (0, log_1.logWarn)(message);
        },
    };
}
async function createDeclarationFile(options, target, forceOverwrite) {
    (0, log_1.progress)('Bundling declaration file ...');
    const result = await (0, dets_1.generateDeclaration)(options);
    (0, log_1.progress)('Writing declaration file ...');
    await (0, io_1.createFileIfNotExists)(target, 'index.d.ts', result, forceOverwrite);
}
async function createPiletDeclaration(piralInstances, root, entry, allowedImports, target, forceOverwrite, logLevel) {
    const [piralInstance] = piralInstances;
    const apis = await findPiralInstanceApi(root, piralInstance);
    const [file] = apis.map((m) => m.file);
    if (file) {
        const files = await getAllFiles([entry]);
        const types = findDeclaredTypings(root);
        const options = {
            name: piralInstance,
            root,
            files,
            types,
            plugins: [(0, dets_1.createDiffPlugin)(file)],
            apis,
            noModuleDeclaration: true,
            imports: allowedImports.filter(m => !piralInstances.includes(m)),
            logLevel,
            logger: createLogger(),
        };
        try {
            await createDeclarationFile(options, target, forceOverwrite);
            return true;
        }
        catch (ex) {
            (0, log_1.log)('declarationCouldNotBeGenerated_0076', root, ex);
        }
        return false;
    }
}
async function createPiralDeclaration(baseDir, entry, target, forceOverwrite, logLevel) {
    (0, log_1.progress)('Reading configuration ...');
    const entryFiles = await (0, package_1.retrievePiralRoot)(baseDir, entry);
    const { name, root, externals, framework, shared } = await (0, package_1.retrievePiletsInfo)(entryFiles);
    const entryModules = await getEntryModules(entryFiles);
    const files = await getAllFiles(entryModules);
    const options = {
        name,
        root,
        files,
        types: findDeclaredTypings(root, shared),
        apis: findPiralBaseApi(root, framework),
        noModuleDeclaration: true,
        imports: (0, package_1.flattenExternals)(externals, true),
        logLevel,
        logger: createLogger(),
    };
    (0, package_1.validateSharedDependencies)(externals);
    if (options.apis.length) {
        try {
            await createDeclarationFile(options, target, forceOverwrite);
            return true;
        }
        catch (ex) {
            (0, log_1.log)('declarationCouldNotBeGenerated_0076', baseDir, ex);
        }
    }
    else {
        (0, log_1.log)('declarationCouldNotBeGenerated_0076', baseDir, 'The main Pilet API interface could not be found.');
    }
    return false;
}
//# sourceMappingURL=declaration.js.map