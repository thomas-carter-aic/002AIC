"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateFromEmulatorWebsite = updateFromEmulatorWebsite;
exports.scaffoldFromEmulatorWebsite = scaffoldFromEmulatorWebsite;
const path_1 = require("path");
const template_1 = require("./template");
const http_1 = require("./http");
const constants_1 = require("./constants");
const config_1 = require("./config");
const enums_1 = require("./enums");
const io_1 = require("./io");
const io_2 = require("./io");
const log_1 = require("./log");
const external_1 = require("../external");
async function requestManifest(url, httpsAgent, interactive) {
    const opts = (0, http_1.getAxiosOptions)(url);
    try {
        return await external_1.axios.get(url, { ...opts, httpsAgent });
    }
    catch (error) {
        return await (0, http_1.handleAxiosError)(error, interactive, httpsAgent, async (mode, key) => {
            const headers = (0, http_1.getAuthorizationHeaders)(mode, key);
            await (0, config_1.updateConfig)('auth', {
                [url]: {
                    mode: 'header',
                    key: 'authorization',
                    value: headers.authorization,
                },
            });
            return await requestManifest(url, httpsAgent, false);
        });
    }
}
async function downloadEmulatorFiles(manifestUrl, targetDir, appDir, files, httpsAgent) {
    const requiredFiles = [files.typings, files.main, files.app];
    const optionalFiles = [files.always, files.once];
    const opts = {
        ...(0, http_1.getAxiosOptions)(manifestUrl),
        httpsAgent,
        responseType: 'arraybuffer',
    };
    const downloadFiles = (files, target) => {
        return files
            .filter((file) => file && typeof file === 'string')
            .map(async (file) => {
            const url = new URL(file, manifestUrl);
            const res = await external_1.axios.get(url.href, opts);
            const data = res.data;
            await (0, io_1.writeBinary)(target, file, data);
        });
    };
    await Promise.all([...downloadFiles(requiredFiles, appDir), ...downloadFiles(optionalFiles, targetDir)]);
}
async function createEmulatorFiles(targetDir, appDir, manifestUrl, emulatorJson, httpsAgent) {
    const mainFile = 'index.js';
    const appDirName = (0, path_1.relative)(targetDir, appDir);
    await (0, io_2.writeJson)(targetDir, constants_1.packageJson, {
        name: emulatorJson.name,
        description: emulatorJson.description,
        version: emulatorJson.version,
        importmap: emulatorJson.importmap,
        pilets: emulatorJson.scaffolding.pilets,
        piralCLI: {
            version: emulatorJson.scaffolding.cli,
            timestamp: emulatorJson.timestamp,
            source: manifestUrl,
            generated: true,
        },
        files: emulatorJson.files.assets,
        main: path_1.posix.join(appDirName, mainFile),
        typings: path_1.posix.join(appDirName, emulatorJson.files.typings),
        app: path_1.posix.join(appDirName, emulatorJson.files.app),
        peerDependencies: {},
        optionalDependencies: emulatorJson.dependencies.optional,
        devDependencies: emulatorJson.dependencies.included,
        sharedDependencies: [Object.keys(emulatorJson.importmap.imports)],
    }, true);
    // actually including this one hints that the app shell should have been included - which is forbidden
    await (0, template_1.createPiralStubIndexIfNotExists)(appDir, mainFile, enums_1.ForceOverwrite.yes, {
        name: emulatorJson.name,
        outFile: emulatorJson.files.main,
    });
    await downloadEmulatorFiles(manifestUrl, targetDir, appDir, emulatorJson.files, httpsAgent);
}
async function updateFromEmulatorWebsite(targetDir, manifestUrl, httpsAgent, interactive) {
    (0, log_1.progress)(`Updating emulator from %s ...`, manifestUrl);
    try {
        const response = await requestManifest(manifestUrl, httpsAgent, interactive);
        const nextEmulator = response.data;
        const currentEmulator = await (0, io_1.readJson)(targetDir, constants_1.packageJson);
        if (currentEmulator.name !== nextEmulator.name) {
            (0, log_1.log)('remoteEmulatorNameChanged_0121', currentEmulator.name);
        }
        else if (currentEmulator.piralCLI.timstamp !== nextEmulator.timestamp) {
            (0, log_1.log)('generalDebug_0003', `The timestamp on "${currentEmulator.name}" is different (${nextEmulator.timestamp}).`);
            const appDir = (0, path_1.resolve)(targetDir, 'app');
            await createEmulatorFiles(targetDir, appDir, manifestUrl, nextEmulator, httpsAgent);
        }
        else {
            (0, log_1.log)('generalDebug_0003', `Nothing to update for "${currentEmulator.name}".`);
        }
    }
    catch (ex) {
        (0, log_1.log)('generalDebug_0003', `HTTP request for emulator update failed: ${ex}`);
        (0, log_1.log)('skipEmulatorUpdate_0120', manifestUrl);
    }
}
async function scaffoldFromEmulatorWebsite(rootDir, manifestUrl, httpsAgent) {
    (0, log_1.progress)(`Downloading emulator from %s ...`, manifestUrl);
    const interactive = (0, external_1.isInteractive)();
    const response = await requestManifest(manifestUrl, httpsAgent, interactive);
    const emulatorJson = response.data;
    const targetDir = (0, path_1.resolve)(rootDir, 'node_modules', emulatorJson.name);
    const appDir = (0, path_1.resolve)(targetDir, 'app');
    await (0, io_1.createDirectory)(appDir);
    await createEmulatorFiles(targetDir, appDir, manifestUrl, emulatorJson, httpsAgent);
    return { name: emulatorJson.name, path: targetDir };
}
//# sourceMappingURL=website.js.map