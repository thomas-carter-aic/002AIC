"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPiletPackage = createPiletPackage;
const path_1 = require("path");
const archive_1 = require("./archive");
const utils_1 = require("./utils");
const log_1 = require("./log");
const io_1 = require("./io");
const inspect_1 = require("./inspect");
async function getPiletContentDir(root, packageData) {
    const paths = (0, inspect_1.getPossiblePiletMainPaths)(packageData);
    for (const path of paths) {
        const file = (0, path_1.resolve)(root, path);
        if (await (0, io_1.checkExists)(file)) {
            return (0, path_1.dirname)(file);
        }
    }
    return root;
}
async function getUniqueFiles(files) {
    const result = [];
    for (const file of files) {
        const isDirectory = await (0, io_1.checkIsDirectory)(file);
        if (isDirectory) {
            const names = await (0, io_1.getFileNames)(file);
            const subFiles = names.map((name) => (0, path_1.resolve)(file, name));
            const items = await getUniqueFiles(subFiles);
            const unique = items.filter((m) => (0, utils_1.onlyUniqueFiles)(m, result.length, result));
            result.push(...unique);
        }
        else if ((0, utils_1.onlyUniqueFiles)(file, result.length, result)) {
            result.push(file);
        }
    }
    return result;
}
async function createPiletPackage(baseDir, source, target) {
    const root = (0, path_1.resolve)(baseDir, source);
    const dest = (0, path_1.resolve)(baseDir, target);
    (0, log_1.log)('generalDebug_0003', `Reading the package at "${root}" ...`);
    const pckg = await (0, io_1.readJson)(root, 'package.json');
    (0, log_1.log)('generalDebug_0003', 'Successfully read package.');
    if (!pckg) {
        (0, log_1.fail)('packageJsonNotFound_0020');
    }
    if (!pckg.name) {
        (0, log_1.fail)('packageJsonMissingName_0021');
    }
    if (!pckg.version) {
        (0, log_1.fail)('packageJsonMissingVersion_0022');
    }
    const isFileTarget = target.endsWith('.tgz');
    (0, log_1.progress)(`Packing pilet in "${root}" ...`);
    const pckgName = pckg.name.replace(/@/g, '').replace(/\//g, '-');
    const id = `${pckgName}-${pckg.version}`;
    const name = isFileTarget ? (0, path_1.basename)(target) : `${id}.tgz`;
    const file = isFileTarget ? dest : (0, path_1.resolve)(dest, name);
    (0, log_1.log)('generalDebug_0003', `Assume package name "${name}".`);
    const content = await getPiletContentDir(root, pckg);
    const files = [(0, path_1.resolve)(root, 'package.json'), content];
    const readme = (0, path_1.resolve)(root, 'README.md');
    if (Array.isArray(pckg.files)) {
        const additionalFiles = pckg.files
            .filter((f) => typeof f === 'string')
            .map((f) => (0, path_1.resolve)(root, f));
        files.push(...additionalFiles);
    }
    if (await (0, io_1.checkExists)(readme)) {
        files.push(readme);
    }
    (0, log_1.log)('generalDebug_0003', `Reading out unique files from "${content}" ...`);
    const uniqueFiles = await getUniqueFiles(files);
    // Edge case: If the files to be packaged contains the destination .tgz file, e.g., as a leftover
    // from a previous build/pack, exclude that file, because it will be overwritten/replaced in the
    // upcoming steps.
    if (uniqueFiles.includes(file)) {
        uniqueFiles.splice(uniqueFiles.indexOf(file), 1);
    }
    (0, log_1.log)('generalDebug_0003', `Creating directory if not exist for "${file}" ...`);
    await (0, io_1.createDirectory)((0, path_1.dirname)(file));
    (0, log_1.log)('generalDebug_0003', `Creating compressed archive at "${file}" relative to "${root}" ...`);
    await (0, archive_1.createTgz)(file, root, uniqueFiles.map((file) => (0, path_1.relative)(root, file)));
    (0, log_1.log)('generalDebug_0003', `Successfully created package "${file}" from "${root}".`);
    return file;
}
//# sourceMappingURL=pack.js.map