"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.patchModules = patchModules;
const path_1 = require("path");
const log_1 = require("./log");
const patches_1 = require("./patches");
const hash_1 = require("./hash");
const enums_1 = require("./enums");
const io_1 = require("./io");
async function patchModule(packageName, rootDir) {
    const applyPatchAt = (0, patches_1.getPatch)(packageName);
    if (typeof applyPatchAt === 'function') {
        (0, log_1.log)('generalDebug_0003', `Applying patchers for ${packageName} in "${rootDir}" ...`);
        await applyPatchAt(rootDir);
    }
}
// See https://github.com/smapiot/piral/issues/121#issuecomment-572055594
const defaultIgnoredPackages = ['core-js'];
/**
 * The motivation for this method came from:
 * https://github.com/parcel-bundler/parcel/issues/1655#issuecomment-568175592
 * General idea:
 * Treat all modules as non-optimized for the current output target.
 * This makes sense in general as only the application should determine the target.
 */
async function patch(staticPath, ignoredPackages) {
    (0, log_1.log)('generalDebug_0003', `Patching files in "${staticPath}" ...`);
    const folderNames = await (0, io_1.getFileNames)(staticPath);
    return Promise.all(folderNames.map(async (folderName) => {
        if (!ignoredPackages.includes(folderName)) {
            const rootName = (0, path_1.resolve)(staticPath, folderName);
            const isDirectory = await (0, io_1.checkIsDirectory)(rootName);
            if (isDirectory) {
                if (folderName.startsWith('@')) {
                    // if we are scoped, just go down
                    await patch(rootName, ignoredPackages);
                }
                else {
                    try {
                        const packageFileData = await (0, io_1.readJson)(rootName, 'package.json');
                        if (packageFileData.name && packageFileData._piralOptimized === undefined) {
                            packageFileData._piralOptimized = packageFileData.browserslist || true;
                            delete packageFileData.browserslist;
                            await (0, io_1.writeJson)(rootName, 'package.json', packageFileData, true);
                            await (0, io_1.writeText)(rootName, '.browserslistrc', 'node 10.11\n');
                            await patchModule(folderName, rootName);
                        }
                        await patchFolder(rootName, ignoredPackages);
                    }
                    catch (e) {
                        (0, log_1.log)('generalDebug_0003', `Encountered a patching error: ${e}`);
                    }
                }
            }
        }
    }));
}
async function patchFolder(rootDir, ignoredPackages) {
    const file = '.patched';
    const modulesDir = (0, path_1.resolve)(rootDir, 'node_modules');
    const exists = await (0, io_1.checkExists)(modulesDir);
    if (exists) {
        const lockContent = (await (0, io_1.readText)(rootDir, 'package-lock.json')) || (await (0, io_1.readText)(rootDir, 'yarn.lock'));
        const currHash = (0, hash_1.computeHash)(lockContent);
        const prevHash = await (0, io_1.readText)(modulesDir, file);
        (0, log_1.log)('generalDebug_0003', `Evaluated patch module hashes: "${currHash}" and "${prevHash}".`);
        if (prevHash !== currHash) {
            await patch(modulesDir, ignoredPackages);
            await (0, io_1.createFileIfNotExists)(modulesDir, file, currHash, enums_1.ForceOverwrite.yes);
        }
    }
}
async function patchModules(rootDir, ignoredPackages = defaultIgnoredPackages) {
    (0, log_1.log)('generalDebug_0003', `Patching modules starting in "${rootDir}" ...`);
    const otherRoot = (0, path_1.resolve)(require.resolve('piral-cli/package.json'), '..', '..', '..');
    await patchFolder(rootDir, ignoredPackages);
    if (otherRoot !== rootDir) {
        (0, log_1.log)('generalDebug_0003', `Also patching modules in "${otherRoot}" ...`);
        await patchFolder(otherRoot, ignoredPackages);
    }
}
//# sourceMappingURL=patcher.js.map