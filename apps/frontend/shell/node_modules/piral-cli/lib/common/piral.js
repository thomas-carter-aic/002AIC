"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.triggerBuildEmulator = triggerBuildEmulator;
exports.triggerBuildShell = triggerBuildShell;
const path_1 = require("path");
const scripts_1 = require("./scripts");
const io_1 = require("./io");
const package_1 = require("./package");
const log_1 = require("./log");
const emulator_1 = require("./emulator");
const constants_1 = require("./constants");
const bundler_1 = require("../bundler");
async function runLifecycle(root, scripts, type) {
    const script = scripts?.[type];
    if (script) {
        (0, log_1.log)('generalDebug_0003', `Running "${type}" ("${script}") ...`);
        await (0, scripts_1.runScript)(script, root);
        (0, log_1.log)('generalDebug_0003', `Finished running "${type}".`);
    }
    else {
        (0, log_1.log)('generalDebug_0003', `No script for "${type}" found ...`);
    }
}
async function triggerBuildEmulator({ root, logLevel, externals, emulatorType, bundlerName, optimizeModules, sourceMaps, watch, ignored, contentHash, targetDir, outFile, scripts, entryFiles, piralInstances, hooks, _, }) {
    (0, log_1.progress)('Starting emulator build ...');
    const emulatorPublicUrl = '/';
    const appDir = emulatorType !== constants_1.emulatorWebsiteName ? (0, path_1.join)(targetDir, 'app') : targetDir;
    // since we create this anyway let's just pretend we want to have it clean!
    await (0, io_1.removeDirectory)(targetDir);
    await hooks.beforeBuild?.({ root, publicUrl: emulatorPublicUrl, externals, entryFiles, targetDir, piralInstances });
    (0, log_1.logInfo)(`Bundle ${constants_1.emulatorName} ...`);
    const { dir: outDir, name, hash, } = await (0, bundler_1.callPiralBuild)({
        root,
        piralInstances,
        emulator: true,
        standalone: false,
        optimizeModules,
        sourceMaps,
        watch,
        contentHash,
        minify: false,
        externals: (0, package_1.flattenExternals)(externals),
        publicUrl: emulatorPublicUrl,
        entryFiles,
        logLevel,
        ignored,
        outDir: appDir,
        outFile,
        _,
    }, bundlerName);
    await hooks.afterBuild?.({
        root,
        publicUrl: emulatorPublicUrl,
        externals,
        entryFiles,
        targetDir,
        piralInstances,
        hash,
        outDir,
        outFile: name,
    });
    await runLifecycle(root, scripts, 'piral:postbuild');
    await runLifecycle(root, scripts, `piral:postbuild-${constants_1.emulatorName}`);
    await hooks.beforeEmulator?.({ root, externals, targetDir, outDir });
    let rootDir = root;
    switch (emulatorType) {
        case constants_1.emulatorPackageName:
            rootDir = await (0, emulator_1.createEmulatorSources)(root, externals, outDir, outFile, logLevel);
            await hooks.beforePackage?.({ root, externals, targetDir, outDir, rootDir });
            await (0, emulator_1.packageEmulator)(rootDir);
            await hooks.afterPackage?.({ root, externals, targetDir, outDir, rootDir });
            break;
        case constants_1.emulatorSourcesName:
            rootDir = await (0, emulator_1.createEmulatorSources)(root, externals, outDir, outFile, logLevel);
            (0, log_1.logDone)(`Emulator package sources available in "${rootDir}".`);
            break;
        case constants_1.emulatorWebsiteName:
            rootDir = await (0, emulator_1.createEmulatorWebsite)(root, externals, outDir, outFile, logLevel);
            (0, log_1.logDone)(`Emulator website available in "${rootDir}".`);
            break;
    }
    await hooks.afterEmulator?.({ root, externals, targetDir, outDir, rootDir });
}
async function triggerBuildShell({ root, targetDir, bundlerName, minify, optimizeModules, entryFiles, piralInstances, sourceMaps, logLevel, ignored, watch, outFile, publicUrl, contentHash, externals, hooks, scripts, _, }) {
    (0, log_1.progress)('Starting release build ...');
    // since we create this anyway let's just pretend we want to have it clean!
    await (0, io_1.removeDirectory)(targetDir);
    (0, log_1.logInfo)(`Bundle ${constants_1.releaseName} ...`);
    await hooks.beforeBuild?.({ root, publicUrl, externals, entryFiles, targetDir, piralInstances });
    const { dir: outDir, name, hash, } = await (0, bundler_1.callPiralBuild)({
        root,
        piralInstances,
        emulator: false,
        standalone: false,
        optimizeModules,
        sourceMaps,
        watch,
        contentHash,
        minify,
        externals: (0, package_1.flattenExternals)(externals),
        publicUrl,
        outFile,
        outDir: targetDir,
        entryFiles,
        logLevel,
        ignored,
        _,
    }, bundlerName);
    await hooks.afterBuild?.({
        root,
        publicUrl,
        externals,
        entryFiles,
        targetDir,
        piralInstances,
        outDir,
        outFile: name,
        hash,
    });
    await runLifecycle(root, scripts, 'piral:postbuild');
    await runLifecycle(root, scripts, `piral:postbuild-${constants_1.releaseName}`);
    (0, log_1.logDone)(`Files for publication available in "${outDir}".`);
}
//# sourceMappingURL=piral.js.map