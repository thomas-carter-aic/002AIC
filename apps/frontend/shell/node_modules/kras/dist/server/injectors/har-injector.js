import { asJson, watch, editDirectoryOption, editEntryOption, fromHar, compareRequests, } from '../helpers';
function delay(value, time) {
    if (time) {
        return new Promise((resolve, reject) => {
            setTimeout(() => resolve(value), time);
        });
    }
    return value;
}
function ato(arr) {
    const obj = {};
    for (const item of arr || []) {
        obj[item.name] = item.value;
    }
    return obj;
}
function getUrl(url) {
    if (url.startsWith('http')) {
        return url.substr(url.indexOf('/', 9));
    }
    return url;
}
function findEntries(obj) {
    if (typeof obj === 'object' && obj.log && Array.isArray(obj.log.entries)) {
        return obj.log.entries;
    }
    return [];
}
export default class HarInjector {
    files = [];
    watcher;
    connectors;
    config;
    constructor(options, config) {
        const directory = options.directory || config.sources || config.directory;
        this.config = options;
        this.connectors = Object.keys(config.map)
            .filter((target) => config.map[target] !== false)
            .map((target) => ({
            target,
            address: config.map[target],
        }));
        this.watcher = watch(directory, ['.har'], (ev, fileName) => {
            switch (ev) {
                case 'create':
                case 'update':
                    return this.load(fileName);
                case 'delete':
                    return this.unload(fileName);
            }
        });
    }
    getOptions() {
        return {
            delay: {
                description: `If active delays the responses with the time it took according to the HAR.`,
                title: `Delay Responses`,
                type: 'checkbox',
                value: this.config.delay || false,
            },
            directories: editDirectoryOption(this.watcher.directories),
            files: editEntryOption(this.files, ({ request }) => `${request.method} ${request.url}`),
        };
    }
    setOptions(options) {
        this.config.delay = options.delay;
        for (const { name, entries } of options.files) {
            const files = this.files.find((m) => m[0].path === name);
            if (entries) {
                for (let i = 0; i < entries.length; i++) {
                    const entry = entries[i];
                    const file = files[i];
                    if (file && typeof entry.active === 'boolean') {
                        file.active = entry.active;
                    }
                }
            }
        }
        this.watcher.directories = options.directories;
    }
    get name() {
        return 'har-injector';
    }
    get active() {
        return this.config.active;
    }
    set active(value) {
        this.config.active = value;
    }
    unload(fileName) {
        const index = this.files.findIndex((m) => m[0].path === fileName);
        if (index !== -1) {
            this.files.splice(index, 1);
        }
    }
    load(fileName) {
        const content = asJson(fileName, undefined);
        const entries = findEntries(content);
        const files = entries.map((entry) => this.transformEntry(fileName, entry));
        this.unload(fileName);
        if (files.length > 0) {
            this.files.push(files);
        }
    }
    findTarget(url) {
        for (const { target, address } of this.connectors) {
            if (url.indexOf(address) === 0) {
                return target;
            }
        }
        return undefined;
    }
    transformEntry(path, entry) {
        const original = entry.request;
        const response = entry.response;
        const content = (original.postData || {}).text || '';
        const request = {
            method: original.method,
            url: getUrl(original.url),
            target: original.target || this.findTarget(original.url),
            content,
            rawContent: content,
            headers: ato(original.headers),
            query: ato(original.queryString),
        };
        delete request.headers._;
        return {
            path,
            active: true,
            time: entry.time,
            request,
            response,
        };
    }
    dispose() {
        this.watcher.close();
    }
    handle(req) {
        let i = 0;
        for (const files of this.files) {
            for (const { path, active, time, request, response } of files) {
                if (active) {
                    const name = this.name;
                    if (compareRequests(request, req)) {
                        return delay(fromHar(request.url, response, {
                            name,
                            file: {
                                name: path,
                                entry: i,
                            },
                        }), this.config.delay && time);
                    }
                }
                i++;
            }
        }
    }
}
