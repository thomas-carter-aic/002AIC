import { asScript, watch, editFileOption, editDirectoryOption, fromJson } from '../helpers';
function errorHandler() {
    return undefined;
}
export async function tryEvaluate(script, ctx) {
    try {
        const handler = await asScript(script.path);
        if (typeof handler !== 'function') {
            throw new Error('Does not export a function - it will be ignored.');
        }
        if (typeof handler?.setup === 'function') {
            handler.setup(ctx);
        }
        script.error = undefined;
        script.handler = handler;
    }
    catch (e) {
        script.error = e;
        script.handler = errorHandler;
    }
}
export default class ScriptInjector {
    files = [];
    core;
    watcher;
    config;
    krasConfig;
    constructor(options, config, core) {
        const directory = options.directory || config.sources || config.directory;
        this.config = options;
        this.core = core;
        this.krasConfig = config;
        this.watcher = watch(directory, ['.js', '.mjs', '.cjs'], (ev, fileName) => {
            switch (ev) {
                case 'create':
                case 'update':
                    return this.load(fileName);
                case 'delete':
                    return this.unload(fileName);
            }
        });
        core.on('user-connected', (e) => {
            if (!e.handled) {
                for (const { handler } of this.files) {
                    if (handler && typeof handler.connected === 'function') {
                        const ctx = this.getContext();
                        try {
                            if (handler.connected(ctx, e)) {
                                e.handled = true;
                                break;
                            }
                        }
                        catch (err) {
                            core.emit('error', err);
                        }
                    }
                }
            }
        });
        core.on('user-disconnected', (e) => {
            for (const { handler } of this.files) {
                if (handler && typeof handler.disconnected === 'function') {
                    const ctx = this.getContext();
                    try {
                        handler.disconnected(ctx, e);
                    }
                    catch (err) {
                        core.emit('error', err);
                    }
                }
            }
        });
    }
    getContext() {
        const extended = this.config.extended || {};
        return {
            $server: this.core,
            $options: this.config,
            $config: this.krasConfig,
            ...extended,
        };
    }
    getOptions() {
        return {
            directories: editDirectoryOption(this.watcher.directories),
            files: editFileOption(this.files),
            extended: {
                description: 'The options available to all script files via the context argument.',
                title: 'Extended Configuration',
                type: 'json',
                value: JSON.stringify(this.config.extended || {}, undefined, 2),
            },
        };
    }
    setOptions(options) {
        for (const { name, active } of options.files) {
            const script = this.files.find((f) => f.path === name);
            if (script && typeof active === 'boolean') {
                script.active = active;
            }
        }
        this.config.extended = JSON.parse(options.extended || '{}');
        this.watcher.directories = options.directories;
    }
    get name() {
        return 'script-injector';
    }
    get active() {
        return this.config.active;
    }
    set active(value) {
        this.config.active = value;
    }
    unload(fileName) {
        const index = this.files.findIndex(({ path }) => path === fileName);
        if (index !== -1) {
            const file = this.files[index];
            const handler = file.handler;
            if (typeof handler?.teardown === 'function') {
                const ctx = this.getContext();
                try {
                    handler.teardown(ctx);
                }
                catch (err) {
                    this.core.emit('error', err);
                }
            }
            this.files.splice(index, 1);
        }
    }
    async load(fileName) {
        const file = this.files.find(({ path }) => path === fileName);
        const active = file?.active ?? true;
        const script = { path: fileName, active };
        const ctx = this.getContext();
        if (file) {
            this.unload(fileName);
        }
        await tryEvaluate(script, ctx);
        if (script.error) {
            this.core.emit('error', script.error);
        }
        else {
            this.files.push(script);
        }
    }
    dispose() {
        this.watcher.close();
    }
    handle(req) {
        for (const { path, active, handler } of this.files) {
            const name = this.name;
            if (active) {
                const builder = ({ statusCode = 200, statusText = '', headers = {}, content = '' }) => fromJson(req.url, statusCode, statusText, headers, content, {
                    name,
                    file: {
                        name: path,
                    },
                });
                const ctx = this.getContext();
                try {
                    const res = handler(ctx, req, builder);
                    if (res) {
                        return res;
                    }
                }
                catch (err) {
                    this.core.emit('error', err);
                }
            }
        }
    }
}
